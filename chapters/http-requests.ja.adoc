[[http-requests]]
= HTTPリクエスト

[#148]
== {MUST} HTTPメソッドを正しく使う

標準のHTTPメソッドの意味は次のとおりである。
Be compliant with the standardized HTTP method semantics summarized as
follows:

[[get]]
=== GET

GETリクエストは、単一のリソースの読み込み、またはリソースの集合のクエリのために使用される。

* 個々のGETリクエストは、リソースが存在しなければ通常404となる。
* リソースのコレクションへのGETのリクエストは、(リストが空であれば) 200を、
(リスト自体が存在しなければ) 404が返る。
* GETリクエストはボディのペイロードをもってはいけない。

*注意:* リソースのコレクションへのGETリクエスト、<<pagination>>だけでなく、
十分なフィルタメカニズムを提供するべきです。

[[get-with-body]]
=== "ボディ付きのGET"

APIはときどきこの問題に直面します。
API設計者は次の2の選択肢をチェックしなければなりません。
APIs sometimes face the problem, that they have to provide extensive
structured request information with GET, that may even conflicts with
the size limits of clients, load-balancers, and servers. As we require
APIs to be standard conform (body in GET must be ignored on server
side), API designers have to check the following two options:

1.  URLエンコードされたクエリパラメータ付きのGET:
クライアント、ゲートウェイ、サーバの通常のサイズ制限を守りつつ
クエリパラメータにリクエスト情報をエンコードできるのであれば、
これが第1の選択肢です。リクエスト情報は、複数のクエリパラメータ分散してもたせてもよいし、
単一のパラメータにURLエンコードしてもたせてもかまいません。
2.  ボディコンテンツ付きのPOST: URLエンコードされたクエリパラメータ付きのGETが
どうしても制限に引っかかる場合は、ボディコンテンツ付きのPOSTを使わねばなりません。
この場合、エンドポイントは`GET with body`ヒントを必ずドキュメントに付けて、
GETの意味での呼び出しであることを伝えなければなりません。

*注意:* ヘッダに構造化されたリクエスト情報をエンコードすることは選択肢にはなりません。
コンセプト上の観点から、常にリソース名とクエリパラメータ(つまりURLになるもの)で
操作の意味を表さなくてはなりません。
リクエストヘッダは、例えばFlowIDのような、一般的な文脈情報のために予約されています。
おまけにクエリパラメータとヘッダのサイズ上限には、これで決まりというものはなく、
クライアント、ゲートウェイ、サーバの設定に依存したものです。
だから、ヘッダに切り替えたからといって何も問題は解決しないのです。

[[put]]
=== PUT

PUTのリクエストは、リソース*全体*の作成、更新に使われます。
単一のリソース、リソースのコレクション両方が対象です。このPUTの意味は、
»_、URLが表すリソースを、このオブジェクトで既存のリソースと置き換えてください_« として表現がしっくりきます。

PUT requests are used to create or update *entire* resources - single or
collection resources. The semantic is best described as »_please put the
enclosed representation at the resource mentioned by the URL, replacing
any existing resource._«.

* PUTリクエストは通常はコレクションでなく単一リソースに適用されるものです。
コレクションに対するPUTは、その全体を置き換えることを暗に意味するからです。
* PUTリクエストは更新前に暗黙的にリソースの作成をおこなうことによって、
存在しないリソースに対しても問題を起こしません。
* PUTリクエストが成功したことは、サーバがペイロードに**
on successful PUT requests, the server will *replace the entire
resource* addressed by the URL with the representation passed in the
payload (subsequent reads will deliver the same payload)
* successful PUT requests will usually generate 200 or 204 (if the
resource was updated - with or without actual content returned), and 201
(if the resource was created)

*注意:* PUTリクエストと関連したリソースIDは、クライアントが保持し、URLパスセグメントで受け渡しします。
同一のリソースに2度PUTしても、
もしPUTがリソースの作成に適用されたら、リソースIDとしてはURLのみが許可されるべきです。
もしURIが利用できない場合は、POSTが優先されるべきです。
*Note:* Resource IDs with respect to PUT requests are maintained by the
client and passed as a URL path segment. Putting the same resource twice
is required to be idempotent and to result in the same single resource
instance. If PUT is applied for creating a resource, only URIs should be
allowed as resource IDs. If URIs are not available POST should be
preferred.

PUTを使うときに意図せず同時更新してしまうことを防ぐため、<<182,`ETag` と `If-(None-)Match`>>ヘッダの
組み合わせで、コンフリクトを表明し変更を失わないようにするために、サーバに厳密な要求を送るようにしましょう。
<<optimistic-locking>>セクションでもこのアプローチの代替案を記述しています。

To prevent unnoticed concurrent updates when using PUT, the combination
of <<182,`ETag` and `If-(None-)Match`>> headers should be considered to signal the server
stricter demands to expose conflicts and prevent lost updates. The section <<optimistic-locking>> also describes some
alternatives to this approach.

[[post]]
=== POST

POSTは慣例的には、リソースのコレクションのエンドポイントに、単一のリソースを作成するのに使われますが、
単一リソースエンドポイントに別の。
コレクションのエンドポイントは、»_URLによって識別されるリソースのコレクションにオブジェクト追加してください_«。
単一のエンドポイントは、»_URLによって識別されるリソースのコレクションににオブジェクト実行してください_«。
POST requests are idiomatically used to create single resources on a
collection resource endpoint, but other semantics on single resources
endpoint are equally possible. The semantic for collection endpoints is
best described as »_please add the enclosed representation to the
collection resource identified by the URL_«. The semantic for single
resource endpoints is best described as »_please execute the given well
specified request on the collection resource identified by the URL_«.

* POSTリクエストはリソースのコレクションだけに適用されるべきである。通常単一リソースに対しては、
これは未定義の意味をもつ。
POST request should only be applied to collection resources, and
normally not on single resource, as this has an undefined semantic
* POSTリクエストが成功したら、サーバは1つまたは複数のリソースを作成し、そのURI/URLをレスポンスとして返す。
* POSTリクエストは成功したら、ふつうは(リソースがアプデートされたら) 200を、(リソースが作成されたら) 201を、
(リクエストは受け付けたが、まだ完了していないのであれば) 202を返す。

*より一般的に:* POSTは、他のHTTPメソッドだと十分でないシナリオのためにも使われるべきである。
例えば複雑なGET、URL長の制約を超えるので、リクエストボディのペイロードとして渡さざるを得ない
(SQLのような構造化)クエリがそれにあたります。
そのような場合は、POSTがワークアラウンドとして使われていることをドキュメントに明記しましょう。

*Note:* Resource IDs with respect to POST requests are created and
maintained by server and returned with response payload. Posting the
same resource twice is by itself *not* required to be idempotent and may
result in multiple resource instances. Anyhow, if external URIs are
present that can be used to identify duplicate requests, it is best
practice to implement POST in an idempotent way.

[[patch]]
=== PATCH

PATCH request are only used for partial update of single resources, i.e.
where only a specific subset of resource fields should be replaced. The
semantic is best described as »_please change the resource identified by
the URL according to my change request_«. The semantic of the change
request is not defined in the HTTP standard and must be described in the
API specification by using suitable media types.

* PATCH requests are usually applied to single resources, and not on
collection resources, as this would imply patching on the entire
collection
* PATCH requests are usually not robust against non-existence of
resource instances
* on successful PATCH requests, the server will update parts of the
resource addressed by the URL as defined by the change request in the
payload
* successful PATCH requests will usually generate 200 or 204 (if
resources have been updated
* with or without updated content returned)

*Note:* since implementing PATCH correctly is a bit tricky, we strongly
suggest to choose one and only one of the following patterns per
endpoint, unless forced by a <<106,backwards compatible change>>.
In preference order:

1.  use PUT with complete objects to update a resource as long as
feasible (i.e. do not use PATCH at all).
2.  use PATCH with partial objects to only update parts of a resource,
whenever possible. (This is basically
https://tools.ietf.org/html/rfc7396[JSON Merge Patch], a specialized
media type `application/merge-patch+json` that is a partial resource
representation.)
3.  use PATCH with http://tools.ietf.org/html/rfc6902[JSON Patch], a
specialized media type `application/json-patch+json` that includes
instructions on how to change the resource.
4.  use POST (with a proper description of what is happening) instead of
PATCH if the request does not modify the resource in a way defined by
the semantics of the media type.

In practice https://tools.ietf.org/html/rfc7396[JSON Merge Patch]
quickly turns out to be too limited, especially when trying to update
single objects in large collections (as part of the resource). In this
cases http://tools.ietf.org/html/rfc6902[JSON Patch] can shown its full
power while still showing readable patch requests
(see also http://erosb.github.io/post/json-patch-vs-merge-patch[JSON patch vs. merge]).

To prevent unnoticed concurrent updates when using PATCH, the
combination of <<182,`ETag`and `If-Match`>> headers should be considered to
signal the server stricter demands to expose conflicts and prevent lost updates.

[#delete]
=== DELETE

DELETE request are used to delete resources. The semantic is best
described as »_please delete the resource identified by the URL_«.

* DELETE requests are usually applied to single resources, not on
collection resources, as this would imply deleting the entire collection
* successful DELETE request will usually generate 200 (if the deleted
resource is returned) or 204 (if no content is returned)
* failed DELETE request will usually generate 404 (if the resource
cannot be found) or 410 (if the resource was already deleted before)

[[head]]
=== HEAD

HEADリクエストは、単一のリソースまたはリソースのコレクションについてのヘッダ情報だけを取得するのに使われます。

* HEADはGETと正確に同じ意味を持ちますが、ボディは返されず、ヘッダのみが返されます。

[[options]]
=== OPTIONS

OPTIONSリクエストは、与えられたエンドポイントの利用可能な操作(HTTPメソッド)が何かを調べるのに使われます。

* OPTIONSは通常、利用可能なメソッドをカンマ繋ぎにしたものを(`Allow:`-ヘッダで)返すか、
リンクテンプレートのリストとして返されます。

*注意:* OPTIONSを実装することはあまりありません。

[#149]
== {MUST} メソッド毎の安全性と冪等性を満たす

HTTPメソッドには以下の性質の有無に違いがあります。

* 冪等性。すなわち、何度実行されてもサーバの状態は同じ影響しか与えないこと。(注意: これは同じレスポンスまたはステータスコードを返す必要はありません)
* 安全性。すなわち状態変化のような副作用がないこと。

メソッドの実装は、次の基本的な性質が満たされなければなりません。

[cols=",,",options="header",]
|=============================
|HTTPメソッド |安全性 |冪等性
|OPTIONS |Yes |Yes
|HEAD |Yes |Yes
|GET |Yes |Yes
|PUT |No |Yes
|POST |No |No
|DELETE |No |Yes
|PATCH |No |No
|=============================

[#154]
== {SHOULD} クエリパラメータのコレクションフォーマットは明示的に定義する

クエリパラメータで値の集合を渡すには、いくつかの方法があります。
どれか1つを選択し、API定義に明示します。
OpenAPIプロパティの http://swagger.io/specification/[`collectionFormat`]
は、クエリパラメータのフォーマットを指定するのに使われます。

複数値をもつクエリパラメータには、`csv` または `multi` いずれかのフォーマットを使うべきです。

[,cols="15%,25%,60%",options="header",]
|=======================================================================
|Collection Format |Description |Example
|`csv` |カンマで分割された値 |`?parameter=value1,value2,value3`

|`multi` |複数パラメータのインスタンス
|`?parameter=value1&parameter=value2&parameter=value3`
|=======================================================================

コレクションフォーマットを選択する際には、ツールのサポート、特殊文字のエスケープ、URLの最大長
を超えないかに注意してください。
