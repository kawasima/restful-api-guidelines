[[performance]]
= 性能

[#155]
== {SHOULD} 必要な帯域幅を減らし応答性を改善する

APIはクライアントの必要性に応じて、帯域幅を減らすための仕組みをサポートすべきです。
パブリックなインターネットやテレコミュニケーションネットワークのように、
大きなペイロードをもち高トラフィックなシナリオで使われる(かもしれない)APIに有効です。
低帯域での通信を余儀なくされるモバイルWebアプリのクライアントが使うAPIは、その典型例です。
(Zalandoは'モバイルファースト'な企業なので、この点は心にとどめておきましょう)

共通のテクニックは、

* <<156,gzip圧縮>>
* リソース属性のサブセットを取得できるよう、フィールドフィルタをクエリに実装する (see <<157>> below)
* paginate lists of data items (see <<pagination>> below)
* `ETag` と `If-(None-)Match` ヘッダを使って、変更のないリソースの再フェッチを避ける (see <<182>>)
* 巨大な結果セットに対しては、ページネーションを使ったインクリメントにアクセスする

それぞれの詳細は以下に示します。

[#156]
== {SHOULD} gzip圧縮を使う

圧縮時間がボトルネックになるほど多くのリクエストを捌かなければならないなど、
特別な理由がない限りは、APIレスポンスのペイロードをgzipで圧縮しましょう。
そうすることでネットワークの転送も速くなるし、フロントエンドの応答性も向上します。

gzip圧縮がサーバペイロードのデフォルトの選択肢ではありますが、サーバは
圧縮しないペイロードもサポートするべきです。クライアントはAccept-Encodingリクエストヘッダを
通じてそれをコントロールできます。see also
http://tools.ietf.org/html/rfc7231#section-5.3.4[RFC 7231 Section 5.3.4].

サーバもまたContent-Encodingヘッダを通じて、gzip圧縮が使われていることを明示すべきです。

[#157]
== {SHOULD} リソースフィールドのフィルタリングをサポートする

ユースケースとペイロードサイズに依存して、返却するエンティティのフィールドの
フィルタリングをサポートすることによって、必要とするネットワーク帯域を大いに
減らこすとができるでしょう。
フィールドクエリパラメータを付けることで、クライアントは欲しいデータに応じて、
フィールドのサブセットを決めることができます。
例は https://cloud.google.com/appengine/docs/python/taskqueue/rest/performance#partial-response[Google
AppEngine API's partial response]をみてください。

[[unfiltered]]
=== フィルタなし

[source,http]
----
GET http://api.example.org/resources/123 HTTP/1.1

HTTP/1.1 200 OK
Content-Type: application/json

{
  "id": "cddd5e44-dae0-11e5-8c01-63ed66ab2da5",
  "name": "John Doe",
  "address": "1600 Pennsylvania Avenue Northwest, Washington, DC, United States",
  "birthday": "1984-09-13",
  "partner": {
    "id": "1fb43648-dae1-11e5-aa01-1fbc3abb1cd0",
    "name": "Jane Doe",
    "address": "1600 Pennsylvania Avenue Northwest, Washington, DC, United States",
    "birthday": "1988-04-07"
  }
}
----

[[filtered]]
=== フィルタあり

[source,http]
----
GET http://api.example.org/resources/123?fields=(name,partner(name)) HTTP/1.1

HTTP/1.1 200 OK
Content-Type: application/json

{
  "name": "John Doe",
  "partner": {
    "name": "Jane Doe"
  }
}
----

この例で示されているフィールドフィルタリングは、リクエストパラメータ"fields"を
通じて実現されています。これは次に示す https://en.wikipedia.org/wiki/Backus%E2%80%93Naur_form[BNF] 文法で
定義されたものです。

[source,bnf]
----
<fields> ::= <negation> <fields_expression> | <fields_expression>

<negation> ::= "!"

<fields_expression> ::= "(" <field_set> ")"

<field_set> ::= <qualified_field> | <qualified_field> "," <field_set>

<qualified_field> ::= <field> | <field> <fields_expression>

<field> ::= <DASH_LETTER_DIGIT> | <DASH_LETTER_DIGIT> <field>

<DASH_LETTER_DIGIT> ::= <DASH> | <LETTER> | <DIGIT>

<DASH> ::= "-" | "_"

<LETTER> ::= "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J" | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T" | "U" | "V" | "W" | "X" | "Y" | "Z" | "a" | "b" | "c" | "d" | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n" | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x" | "y" | "z"

<DIGIT> ::= "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"
----

A `fields_expression` as defined by the grammar describes the properties
of an object, i.e. `(name)` returns only the `name` property of the root
object. `(name,partner(name))` returns the `name` and `partner`
properties where `partner` itself is also an object and only its `name`
property is returned.

Hint: OpenAPI doesn't allow you to formally specify whether depending on
a given parameter will return different parts of the specified result
schema. Explain this in English in the parameter description.

[#158]
== {SHOULD} Allow Optional Embedding of Sub-Resources

Embedding related resources (also know as _Resource expansion_) is a
great way to reduce the number of requests. In cases where clients know
upfront that they need some related resources they can instruct the
server to prefetch that data eagerly. Whether this is optimized on the
server, e.g. a database join, or done in a generic way, e.g. an HTTP
proxy that transparently embeds resources, is up to the implementation.

See <<137>> for naming, e.g. "embed" for steering of embedded
resource expansion. Please use the
https://en.wikipedia.org/wiki/Backus%E2%80%93Naur_form[BNF] grammar, as
already defined above for filtering, when it comes to an embedding query
syntax.

Embedding a sub-resource can possibly look like this where an order
resource has its order items as sub-resource (/order/\{orderId}/items):

[source,http]
----
GET /order/123?embed=(items) HTTP/1.1

{
  "id": "123",
  "_embedded": {
    "items": [
      {
        "position": 1,
        "sku": "1234-ABCD-7890",
        "price": {
          "amount": 71.99,
          "currency": "EUR"
        }
      }
    ]
  }
}
----

[217]
== {MUST} サポートされていればキャッシュを使う

If an API is intended to support caching, it must take care to specify
this ability by defining the caching boundaries i.e. time-to-live and
cache constraints, by providing the `Cache-Control` and `Vary` headers
(Please read https://tools.ietf.org/html/rfc7234[RFC-7234] carefully).

Caching has to take many aspects into account, e.g. general cacheability
of response information, our guideline to protect endpoints using SSL
and <<104,OAuth authorization>>, resource update and invalidation rules,
existence of multiple consumer instances. As a consequence, caching is
in best case complex, in worst case inefficient. Thus, client side and
transparent HTTP caching should be avoided for RESTful APIs unless the
API designer has proven to know better.

As default, API providers should set the `Cache-Control: no-cache` header.

**Note:** There is no need to document this default setting, that is
attached to each response automatically by most frameworks. However, any
use deviating from this default must be sufficiently documented.
