[[events]]
= イベント

Zalandoのアーキテクチャは疎結合なマイクロサービス中心で作られているので、
私たちは非同期なイベント駆動のアプローチを好みます。
このセクションのガイドラインは、イベントの設計と送信の仕方にフォーカスしたものになります。

*イベント、イベントの型および分類*

イベントは _イベント型_ と呼ぶ項目を使って定義します。
イベント型は送信者によってスキーマを使って宣言され、受信者によって解釈されるイベント構造をもちます。
イベント型は、名前、オーナーアプリケーション(暗黙的にオーナーのチーム)、エベントのカスタムデータ
を定義したスキーマ、スキーマがどう進化していくかを宣言している互換モードなどを、
標準情報として宣言します。
イベント型では、またイベントのバリデーションや強化戦略、イベントストリームの中で、
イベントがどうパーティショニングされうるか、のような補足情報を宣言してもかまいません。

イベント型は、(データ変更カテゴリのように) _イベントカテゴリ_ に属します。
イベントカテゴリはイベントの種類に共通な追加情報を提供します。

イベント型は チームがみな使えるようAPIリソースとして、典型的には _イベント型レジストリ_
に登録して公開します。送受信されるイベントは、そのイベント型の全体の構造と
カスタムデータのためのスキーマに対して、検証済みのものでなくてはなりません。

上述の基本モデルは、 https://github.com/zalando/nakadi[Nakadi プロジェクト]
として元々開発されたものです。
Nakadiはイベント型のレジストリの参照実装であり、
イベントの送受信者のために、pub-subの検証ブローカとして動作します。

[#194]
== {MUST} サービスインタフェースの一部としてイベントを取り扱う

イベントはサービスのREST APIへ同じ立場であり、外界に対してのサービスインタフェースの
一部です。データを送出するサービスは、APIと同じように、イベントを設計における最重要関心事として
扱わなければなりません。
<<はじめに>>で示した「APIファースト」の原則が、イベントに対しても当てはまります。

[#195]
== {MUST} レビューできるようにEventのスキーマを作る

イベントを送出するサービスは、他で使えるようにイベントのスキーマを作らなければなりません。
それだけでなく、レビューのためにもイベントの型定義も作りましょう。

[#196]
== {MUST} イベントスキーマはOpen APIスキーマオブジェクトに準拠する

API仕様にイベントスキーマ仕様も揃えるために、私たちはイベントスキーマの定義にも
Open API仕様を使ってスキーマオブジェクトを定義します。
これは他のAPIで使われているリソースに関するデータ変更を表すイベントにとって、特に便利なものです。

https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md#schemaObject[Open
API スキーマオブジェクト] は http://json-schema.org/[JSON Schema Draft 4] の **拡張可能なサブセット** です。
便宜上、私たちは以下にその重要な差異を示します。
詳細は
https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md#schemaObject[Open
API スキーマオブジェクト仕様] を参照ください。

Open APIスキーマオブジェクトは、いくつかのJSONスキーマキーワードが削除されているので、
イベントスキーマでもこれらは使わないようにしてください。

* `additionalItems`
* `contains`
* `patternProperties`
* `dependencies`
* `propertyNames`
* `const`
* `not`
* `oneOf`

一方でスキーマオブジェクトは、JSONスキーマキーワードを再定義しているものもあります。

* `additionalProperties`: 互換性保証を謳うイベント型には、このフィールドを使うことにかんしては制約を設けておたほうがよいでしょう。詳細は<<210>>のガイドラインをみてください。
For event types that declare compatibility
guarantees, there are recommended constraints around the use of this
field. See the guideline <<210>> for details.

最後に、スキーマオブジェクトは、JSONスキーマのいくつかのキーワードを _拡張しています_ 。
Finally, the Schema Object _extends_ JSON Schema with some keywords:

* `readOnly`: イベントが論理的にイミュータブルであることを意味します。
`readOnly`は冗長とみなされるかもしれませんが無害です。
* `discriminator`: `oneOf` の代替としてポリモーフィズムをサポートするため。
* `^x-`: https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md#vendorExtensions[ベンダ拡張] の形式でパターン化されたオブジェクトがイベント型スキーマでも使えます。
しかし、汎用目的のバリデータはバリデーションを実行しませんし、無視されるべき処理にフォールバックします。
将来のガイドラインのバージョンでは、イベントのベンダ拡張について、もっとしっかり定義するかもしれません。

[#197]
== {MUST} イベントはイベント型として登録されていることを保証する

Zalandoのアーキテクチャにおいて、イベントは _イベント型_ と呼ばれる
構造を使って登録されます。イベント型では、次のような標準の情報を宣言します。

* イベントカテゴリ。「汎用」や「データ更新」のように、よく知られたものです。
* イベント型の名前
* 所有アプリケーション
* イベントのペイロードを定義するスキーマ
* 型の互換モード

イベント型はイベント情報を見つけるのを簡単にし、それが良く構造化されていて、
一貫性があって検証可能であることを保証するものになります。

イベント型のオーナーは、互換モードの選択に気をつけなければなりません。
モードはスキーマの進化の意味付けをします。
モードの範囲は、イベント送信者が
Event type owners must pay attention to the choice of compatibility
mode. The mode provides a means to evolve the schema. The range of
modes are designed to be flexible enough so that producers can evolve
schemas while not inadvertently breaking existing consumers:

* `none`: たとえ既存のイベント送信者・受信者を破壊しようと、どんなスキーマの修正も受け入れられる。
イベントを検証する際は、スキーマで宣言されていない未定義のプロパティも受け入れなければ
ならない。
* `forward`: スキーマ `S1` は、以前登録されたスキーマ `S0` が `S1` で定義されたイベントを
読むことができる、すなわちイベント受信者は、 <<api-design-principles>> ガイドラインの
ロバストネスの原則にしたがう限り、以前のバージョンを使っている最新のスキーマバージョンで
タグ付けされたイベントも読むことができます。
* `forward`: A schema `S1` is forward compatible if the previously
registered schema, `S0` can read events defined by `S1` - that is,
consumers can read events tagged with the latest schema version using
the previous version as long as consumers follow the robustness
principle described in the guideline's <<api-design-principles>>.
* `compatible`: これは変更が完全な互換性をもつことを意味します。新しい
スキーマ `S1` は、最初のスキーマバージョン
互換モードでは、既存のスキーマへは新しい任意のプロパティと定義の追加のみ許され、
他の変更は禁止されます。

互換性モードはセマンティックバージョニング (MAJOR.MINOR.PATCH) にしたがう
`version`フィールドで
The compatibility mode interact with revision numbers in the schema
`version` field, which follows semantic versioning (MAJOR.MINOR.PATCH):

* 互換モード `compatible` では、イベント型はPATCHまたはMINORバージョンのみ
変更でき、破壊的変更であるMAJORバージョンアップは許されまない。
* 互換モード `forward` では、イベント型はPATCHまたはMINORバージョンのみ
変更でき、破壊的変更であるMAJORバージョンアップは許されない。
* 互換モード `none` では、イベント型はPATCH、MINOR、MAJORすべてのレベルの
変更ができる。

次の例でこの関係性を説明します。

* イベント型の `title` または `description` を変更することは、PATCHレベルとみなす
* イベント型に任意のフィールドを追加することは、MINORレベルの変更とみなす
* 名前の変更やフィールドの削除、必須フィールドの新規追加など、他のすべての変更はMAJORレベルとみなす。

イベント型の主要な構造は、Open APIオブジェクトとして、以下のように定義されます。

[source,yaml]
----
EventType:
  description: |
    An event type defines the schema and its runtime properties. The required
    fields are the minimum set the creator of an event type is expected to
    supply.
  required:
    - name
    - category
    - owning_application
    - schema
  properties:
    name:
      description: |
        Name of this EventType.  Note: the name can encode the
        owner/responsible for this EventType and ideally should follow a
        naming pattern that makes it easy to read and understand.
      type: string
      pattern: '[a-zA-Z][-0-9a-zA-Z_]*(\.[a-zA-Z][-0-9a-zA-Z_]*)*'
      example: order.order_cancelled, business_partner.contract
    owning_application:
      description: |
        Name of the application (eg, as would be used in infrastructure
        application or service registry) owning this `EventType`.
      type: string
      example: price-service
    category:
      description: Defines the category of this EventType.
      type: string
      x-extensible-enum:
        - data
        - general
    compatibility_mode:
      description: |
        The compatibility mode to evolve the schema.
      type: string
      x-extensible-enum:
        - compatible
        - forward
        - none
      default: forward
    schema:
      description: The most recent payload schema for this EventType.
      type: object
      properties:
        version:
          description: Values are based on semantic versioning (eg "1.2.1").
          type: string
          default: '1.0.0'
        created_at:
          description: Creation timestamp of the schema.
          type: string
          readOnly: true
          format: date-time
          example: '1996-12-19T16:39:57-08:00'
        type:
          description: |
             The schema language of schema definition. Currently only
             json_schema (JSON Schema v04) syntax is defined, but in the
             future there could be others.
          type: string
          x-extensible-enum:
            - json_schema
        schema:
          description: |
              The schema as string in the syntax defined in the field type.
          type: string
      required:
        - type
        - schema
    created_at:
      description: When this event type was created.
      type: string
      pattern: date-time
    updated_at:
      description: When this event type was last updated.
      type: string
      pattern: date-time
----

APIs such as registries supporting event types, may extend the model,
including the set of supported categories and schema formats. For
example the Nakadi API's event category registration also allows the
declaration of validation and enrichment strategies for events, along
with supplemental information, such as how events are partitioned in the
stream.

[#198]
== {MUST} イベントが周知のイベントカテゴリに準拠することを保証する

_イベントカテゴリ_ はイベント型の一般的な分類です。
ガイドラインは2つのカテゴリを定義します。

* 汎用イベント: 汎用目的のカテゴリ
* データ更新イベント: a category used for describing changes to data
entities used for data replication based data integration.

カテゴリは将来的に成長していくことが予想されます。

カテゴリとは、イベント送信者が準拠しなくてはならないイベントの種類(データ更新イベントなど)
に関しての標準を、事前に定義した構造で記述したものです。

*汎用イベントカテゴリ*

_汎用イベントカテゴリ_ は、Open API スキーマオブジェクトの定義として、
以下のような構造で表せます。

[source,yaml]
----
GeneralEvent:
  description: |
    A general kind of event. Event kinds based on this event define their
    custom schema payload as the top level of the document, with the
    "metadata" field being required and reserved for standard metadata. An
    instance of an event based on the event type thus conforms to both the
    EventMetadata definition and the custom schema definition. Previously
    this category was called the Business Category.
  required:
    - metadata
  properties:
    metadata:
        $ref: '#/definitions/EventMetadata'
----

Event types based on the General Event Category define their custom
schema payload at the top-level of the document, with the `metadata`
field being reserved for standard information (the contents of
`metadata` are described further down in this section).

In the example fragment below, the reserved `metadata` field is shown
with fields "a" and "b" being defined as part of the custom schema:

Note:

* The General Event in a previous version of the guidelines was called a
_Business Event_. Implementation experience has shown that the
category's structure gets used for other kinds of events, hence the name
has been generalized to reflect how teams are using it.
* The General Event is still useful and recommended for the purpose of
defining events that drive a business process.
* The Nakadi broker still refers to the General Category as the Business
Category and uses the keyword "business" for event type registration.
Other than that, the JSON structures are identical.

See <<201>> for more guidance on how to use the category.

*データ更新イベントカテゴリ*

_データ更新イベントカテゴリ_ は、Open API スキーマオブジェクトの定義として、
以下のような構造で表せます。

[source,yaml]
----
DataChangeEvent:
  description: |
    Represents a change to an entity. The required fields are those
    expected to be sent by the producer, other fields may be added
    by intermediaries such as a publish/subscribe broker. An instance
    of an event based on the event type conforms to both the
    DataChangeEvent's definition and the custom schema definition.
  required:
    - metadata
    - data_op
    - data_type
    - data
  properties:
    metadata:
      description: The metadata for this event.
      $ref: '#/definitions/EventMetadata'
    data:
      description: |
        Contains custom payload for the event type. The payload must conform
        to a schema associated with the event type declared in the metadata
        object's `event_type` field.
      type: object
    data_type:
      description: name of the (business) data entity that has been mutated
      type: string
      example: 'sales_order.order'
    data_op:
      type: string
      enum: ['C', 'U', 'D', 'S']
      description: |
        The type of operation executed on the entity:

        - C: Creation of an entity
        - U: An update to an entity.
        - D: Deletion of an entity.
        - S: A snapshot of an entity at a point in time.
----

データ更新イベントカテゴリは、構造的に汎用イベントカテゴリとは異なります。
`data` フィールドでカスタムペイロードを定義し、 `data_type` にデータ変更に関する
固有の情報を定義します。
It defines a field called `data` for placing the custom
payload information, as well as specific information related to data
changes in the `data_type`. In the example fragment below, the fields
`a` and `b` are part of the custom payload housed inside the `data`
field:

データ更新イベントカテゴリの使い方の指針は、以下のガイドラインも参照ください。

* <<205>>
* <<202>>
* <<204>>

*イベントメタデータ*

汎用カテゴリもデータ更新イベントカテゴリも、 _メタデータ_ に関しては、
共通の構造をもちます。
メタデータの構造は、Open APIスキーマオブジェクトとして以下のように表せます。

[source,yaml]
----
EventMetadata:
  type: object
  description: |
    Carries metadata for an Event along with common fields. The required
    fields are those expected to be sent by the producer, other fields may be
    added by intermediaries such as publish/subscribe broker.
  required:
    - eid
    - occurred_at
  properties:
    eid:
      description: Identifier of this event.
      type: string
      format: uuid
      example: '105a76d8-db49-4144-ace7-e683e8f4ba46'
    event_type:
      description: The name of the EventType of this Event.
      type: string
      example: 'example.important-business-event'
    occurred_at:
      description: When the event was created according to the producer.
      type: string
      format: date-time
      example: '1996-12-19T16:39:57-08:00'
    received_at:
      description: |
        When the event was seen by an intermediary such as a broker.
      type: string
      readOnly: true
      format: date-time
      example: '1996-12-19T16:39:57-08:00'
    version:
      description: |
        Version of the schema used for validating this event. This may be
        enriched upon reception by intermediaries. This string uses semantic
        versioning.
      type: string
      readOnly: true
    parent_eids:
      description: |
        Event identifiers of the Event that caused the generation of
        this Event. Set by the producer.
      type: array
      items:
        type: string
        format: uuid
      example: '105a76d8-db49-4144-ace7-e683e8f4ba46'
    flow_id:
      description: |
        A flow-id for this event (corresponds to the X-Flow-Id HTTP header).
      type: string
      example: 'JAh6xH4OQhCJ9PutIV_RYw'
    partition:
      description: |
        Indicates the partition assigned to this Event. Used for systems
        where an event type's events can be sub-divided into partitions.
      type: string
      example: '0'
----

Please note than intermediaries acting between the producer of an event
and its ultimate consumers, may perform operations like validation of
events and enrichment of an event's `metadata`. For example brokers such
as Nakadi, can validate and enrich events with arbitrary additional
fields that are not specified here and may set default or other values,
if some of the specified fields are not supplied. How such systems work
is outside the scope of these guidelines but producers and consumers
working with such systems should look into their documentation for
additional information.

[#199]
== {MUST} Ensure that Events define useful business resources

Events are intended to be used by other services including business
process/data analytics and monitoring. They should be based around the
resources and business processes you have defined for your service
domain and adhere to its natural lifecycle (see also <<139>> and <<140>>).

As there is a cost in creating an explosion of event types and topics,
prefer to define event types that are abstract/generic enough to be
valuable for multiple use cases, and avoid publishing event types
without a clear need.

[#200]
== {MUST} Events must not provide sensitive customer personal data

Similar to API permission scopes, there will be Event Type permissions
passed via an OAuth token supported in near future. In the meantime,
teams are asked to note the following:

* Sensitive data, such as (e-mail addresses, phone numbers, etc) are
subject to strict access and data protection controls.
* Event type owners *must not* publish sensitive information unless it's
mandatory or necessary to do so. For example, events sometimes need to
provide personal data, such as delivery addresses in shipment orders (as
do other APIs), and this is fine.

[#201]
== {MUST} Use the General Event Category to signal steps and arrival points in business processes

When publishing events that represent steps in a business process, event
types must be based on the General Event category.

All your events of a single business process will conform to the
following rules:

* Business events must contain a specific identifier field (a business
process id or "bp-id") similar to flow-id to allow for efficient
aggregation of all events in a business process execution.
* Business events must contain a means to correctly order events in a
business process execution. In distributed settings where monotonically
increasing values (such as a high precision timestamp that is assured to
move forwards) cannot be obtained, the `parent_eids` data structure
allows causal relationships to be declared between events.
* Business events should only contain information that is new to the
business process execution at the specific step/arrival point.
* Each business process sequence should be started by a business event
containing all relevant context information.
* Business events must be published reliably by the service.

At the moment we cannot state whether it's best practice to publish all
the events for a business process using a single event type and
represent the specific steps with a state field, or whether to use
multiple event types to represent each step. For now we suggest
assessing each option and sticking to one for a given business process.

[#202]
== {MUST} Use Data Change Events to signal mutations

When publishing events that represents created, updated, or deleted
data, change event types must be based on the Data Change Event
category.

* Change events must identify the changed entity to allow aggregation of
all related events for the entity.
* Change events <<203>>.
* Change events must be published reliably by the service.

[#203]
== {SHOULD} Provide a means for explicit event ordering

Some common error cases may require event consumers to reconstruct event
streams or replay events from a position within the stream. Events
_should_ therefore contain a way to restore their partial order of
occurrence.

This can be done - among other ways - by adding - a strictly
monotonically increasing entity version (e.g. as created by a database)
to allow for partial ordering of all events for an entity - a strictly
monotonically increasing message counter

System timestamps are not necessarily a good choice, since exact
synchronization of clocks in distributed systems is difficult, two
events may occur in the same microsecond and system clocks may jump
backward or forward to compensate drifts or leap-seconds. If you use
system timestamps to indicate event ordering, you must carefully ensure
that your designated event order is not messed up by these effects.

*Note* that basing events on data structures that can be converged upon
in a distributed setting (such as
https://en.wikipedia.org/wiki/Conflict-free_replicated_data_type[CRDTs],
https://en.wikipedia.org/wiki/Logical_clock[logical clocks] and
https://en.wikipedia.org/wiki/Vector_clock[vector clocks]) is outside
the scope of this guidance.

[#204]
== {SHOULD} Use the hash partition strategy for Data Change Events

The `hash` partition strategy allows a producer to define which fields
in an event are used as input to compute a logical partition the event
should be added to. Partitions are useful as they allow supporting
systems to scale their throughput while provide local ordering for event
entities.

The `hash` option is particulary useful for data changes as it allows
all related events for an entity to be consistently assigned to a
partition, providing a relative ordered stream of events for that
entity. This is because while each partition has a total ordering,
ordering across partitions is not assured by a supporting system, thus
it is possible for events sent across partitions to appear in a
different order to consumers that the order they arrived at the server.

When using the `hash` strategy the partition key in almost all cases
should represent the entity being changed and not a per event or change
identifier such as the `eid` field or a timestamp. This ensures data
changes arrive at the same partition for a given entity and can be
consumed effectively by clients.

There may be exceptional cases where data change events could have their
partition strategy set to be the producer defined or random options, but
generally `hash` is the right option - that is while the guidelines here
are a "should", they can be read as "must, unless you have a very good
reason".

[#205]
== {SHOULD} Ensure that Data Change Events match API representations

A data change event's representation of an entity should correspond to
the REST API representation.

There's value in having the fewest number of published structures for a
service. Consumers of the service will be working with fewer
representations, and the service owners will have less API surface to
maintain. In particular, you should only publish events that are
interesting in the domain and abstract away from implementation or local
details - there's no need to reflect every change that happens within
your system.

There are cases where it could make sense to define data change events
that don't directly correspond to your API resource representations.
Some examples are -

* Where the API resource representations are very different from the
datastore representation, but the physical data are easier to reliably
process for data integration.
* Publishing aggregated data. For example a data change to an individual
entity might cause an event to be published that contains a coarser
representation than that defined for an API
* Events that are the result of a computation, such as a matching
algorithm, or the generation of enriched data, and which might not be
stored as entity by the service.

[#206]
== {MUST} イベントの権限はAPIの権限に対応しなければならない

リソースがREST APIを通じて同期的に読み取りアクセスでき、イベントを通じて非同期で読み取りアクセスできると
すると、同じ読み取り権限が適用されていなければならない。
私たちはデータを保護したいのあって、データのアクセス方法を保護したい訳ではないのだから。

[#207]
== {MUST} イベント型のオーナーを明示する

イベント定義は、所有者をハッキリさせておかなければなりません。EventTypeの `owning_application` で明示します。

EventTypeのオーナーでその定義に責任をもつのは、1つの送信アプリケーションであることが
多いですが、そのオーナは同種のイベントを送信する複数のサービスの1つであってもよいです。

[#208]
== {MUST} 全体のガイドラインにしたがってイベントのペイロードを定義する Define Event Payloads in accordance with the overall Guidelines

イベントは他のAPIデータやAPIガイドラインと整合性のとれたものでなくてはなりません。

<<introduction>> で表したすべてが、サービス間でデータをやり取りするイベントに適用されます。
Everything expressed in the <<introduction>> to
these Guidelines is applicable to event data interchange between
services.
APIと同様に、イベントが
This is because our events, just like our APIs, represent a
commitment to express what our systems do and designing high-quality,
useful events allows us to develop new and interesting products and
services.

イベントが他の種類のデータと異なるのは、非同期のpub-subメッセージングのように、
データの伝達に使われるところにあります。ですが、REST APIが、
例えば検索リクエストやページ分割されたフィードを使われるため、イベントでは
利用されないものだ、ということはなく、サービスのREST APIのために作った
モデルを
What distinguishes events from other kinds of data is the delivery style
used, asynchronous publish-subscribe messaging. But there is no reason
why they could not be made available using a REST API, for example via a
search request or as a paginated feed, and it will be common to base
events on the models created for the service’s REST API.

次のガイドラインの章がイベントにも適用されます。

* <<general-guidelines>>
* <<api-naming>>
* <<data-formats>>
* <<common-data-types>>
* <<hypermedia>>

[#209]
== {MUST} イベントのために後方互換性を維持する

イベントの変更は項目追加や後方互換のある変更を基本としなければなりません。
これは <<compatibility>> ガイドラインの「Must: 後方互換性を崩してはならない」
にしたがうものです。

イベントの文脈では、互換性の事情は複雑です。
イベントの送信者も受信者も高度に非同期化されていて、
RESTのクライアント/サーバでは適用できていた content-negotiation を用いた
テクニックは使えないためです。
これは後方互換維持のためのより高いハードルを、受信者側に課すことになります。
要求に応じてバージョニングしたメディアタイプを返すということが出来ないためです。

イベントスキーマでは、受信者側から見たときに、以下のものは後方互換性があると
考えられます。

* JSONオブジェクトへの新しい任意のフィールドの追加
* フィールドの並び順の変更 (オブジェクトにおけるフィールドの並びは任意である)
* 配列内の同じ型の値の並び順変更
* 任意のフィールドの削除
* 列挙型の個々の値の削除

また、受信者側から見たときに、以下のものは後方互換性がないと考えられます。

* JSONオブジェクトから必須のフィールドの削除
* フィールドのデフォルト値の変更
* フィールド、オブジェクト、列挙型、配列の型の変更
* 配列内の異なる型の値の並び順変更 (こういった配列はタプルとして知られている)
* 既存のフィールドを再定義した新しい任意のフィールドの追加 (共起制限として知られている)
* 列挙型への値の追加 (<<112,`x-extensible-enum`>> はJSONスキーマでは使えないことに注意)

[#210]
== {SHOULD} イベント型定義では `additionalProperties` を避ける

イベント型のスキーマでは、スキーマの成長をサポートするため `additionalProperties` の使用を避けるべきです。

イベントはpub-subシステムによって中継されることが多く、共通的にログがとられたり、
後で読み込むためにストレージに保存されたりします。
特に受信者と送信者双方で使われるスキーマは、時間とともに変化していきます。
結果として、クライアント・サーバ型のAPIではあまり起こらなかった互換性と拡張性の問題が、
イベントの設計では重要かつふつうに考えなきゃならいことになってくるのです。
イベントスキーマの成長を可能にするため、ガイドラインは次の点を推奨します。

* Publishers who intend to provide compatibility and allow their schemas
to evolve safely over time *must not* declare an `additionalProperties`
field with a value of `true` (i.e., a wildcard extension point). Instead
they must define new optional fields and update their schemas in advance
of publishing those fields.
* Consumers *must* ignore fields they cannot process and not raise
errors. This can happen if they are processing events with an older copy
of the event schema than the one containing the new definitions
specified by the publishers.

The above constraint does not mean fields can never be added in future
revisions of an event type schema - additive compatible changes are
allowed, only that the new schema for an event type must define the
field first before it is published within an event. By the same turn the
consumer must ignore fields it does not know about from its copy of the
schema, just as they would as an API client - that is, they cannot treat
the absence of an `additionalProperties` field as though the event type
schema was closed for extension.

Requiring event publishers to define their fields ahead of publishing
avoids the problem of _field redefinition_. This is when a publisher
defines a field to be of a different type that was already being
emitted, or, is changing the type of an undefined field. Both of these
are prevented by not using `additionalProperties`.

See also "Treat Open API Definitions As Open For Extension By Default" +
in the <<compatibility>> section for further guidelines on the use of `additionalProperties`.

[#211]
== {MUST} ユニークなイベント識別子を使う

イベントの `eid` (イベント識別子)の値は、ユニークでなくてはなりません。

`eid` プロパティは、イベントの標準のメタデータの一部であり、イベントに識別子を
与えるものです。
送信クライアントは、イベント送出時にこれを生成し、所有アプリケーションの範囲で
ユニーク性を保証しなければなりません。
特に、あるイベント型のストリームをともなうイベントは、ユニークな識別子はマストです。
これはイベント受信者が、 `eid` をイベントがユニークであるとして処理したり、
冪等性のチェックに使ったりするためです。

イベントを受信するシステムが `eid` のユニーク性のチェックすることは任意であるので、
送信者側がイベント識別子のユニーク性を保証する責務があることに注意しましょう。
イベントのユニーク識別子を生成する単純な方法は、UUIDを使うことです。

[#212]
== {SHOULD} 冪等な順不同の処理を設計する

<<149,idempotent>>で順不同の処理をするものとしてイベントを設計しておくと、
非常にレジリエントなシステムとなります。もしイベントの処理に失敗しても、
送信者と受信者は、処理を一時停止したり、処理結果の整合性を崩すことなく、
イベント処理をスキップしたりディレイさせたりリトライしたりできます。

このように処理順を自由にするには、冪等で順不同な処理設計を明示的にやる必要があります。
イベントが元の順序を推測するのに十分な情報を含むようにしたり、業務ドメインが
順序性によらないような方法で設計するようにします。

データ変更イベントと似た共通の例として、冪等で順不同な処理は、次の情報を送る
ことによって達成されます。

* プロセス/リソース/エンティティの識別子
* <<203,monotonically increasing ordering key>>
* 変更後のプロセス/リソースの状態

受信側が現在の状態にだけ関心があるのであれば、各リソースの最新イベントよりも古いものは
無視できます。
受信側がリソースの履歴にも関心があるのであれば、(部分的にでも) 順序性のある一連のイベントを
再生成するために、順番に並んだキーを使います。

[#213]
== {MUST} イベントの型名の規約にしたがう

イベントの型はこれらの命名規約にしたがいましょう。

* イベントの名前はURLセールでなくてはならない。これはイベント型名が、他のシステムや
APIでURLとして使われる可能性があるため。
* イベント型名は、小文字と数字のみからなり、ハイフン、アンダースコアまたはピリオドを
セパレータとして使うことができる。

[#214]
== {MUST} 重複したイベントに備える

イベントの受け手は、重複したイベントを正しく処理できなくてはなりません。

大抵のメッセージブローカとデータストリーミングシステムは、"at-least-once"配信をサポートしています。
これはある特定のイベントが、必ず1回以上は受け手に届くことを保証するものです。
別の状況でも、重複したイベントが発生する可能性があります。

例えば、イベントの送信者が(ネットワークの問題によって) 受け手に届かなかったような
状況で発生します。この場合、送信者は同じイベントの再送を試みます。
こうしてイベントバスに受信者が処理すべき同一のイベントが2つ存在することになります。
同じ状態は受信者側でも起こります: イベントは正しく処理したが、その処理が確認出来ない場合です。
