[[pagination]]
= ページネーション

[#159]
== {MUST} ページネーションをサポートする

リストデータへのアクセスは、クライアントサイドの一括処理と繰り返し操作のために、ページネーションをサポートしなければなりません。これは数百エントリ以上の(になる可能性のある)リストすべてにあてはまります。

2つのページネーションのテクニックがあります。

* http://developer.infoconnect.com/paging-results-limit-and-offset[Limit/Offsetベース]: 最初のページエントリをオフセット数値で特定する
* https://dev.twitter.com/overview/api/cursoring[カーソルベース] — またの名を
キーベース — ページネーション: 単一のキー要素で最初のページエントリを特定する
(https://developers.facebook.com/docs/graph-api/using-graph-api/v2.4#paging[Facebookのガイド]も見てください)

ページネーションの技術的概念は、問題がユーザエクスペリエンスと結びついていることも考慮しなければなりません。
この https://www.smashingmagazine.com/2016/03/pagination-infinite-scrolling-load-more-buttons/[記事] で述べられているとおり、
特定のページへのジャンプは、「前へ」「次へ」のページリンクよりもかなり使われることはありません。
それがオフセットベースのページネーションよりも、カーソルベースのページネーションを指向したい理由です。

[#160]
== {SHOULD} Offsetベースのページネーションを避け、カーソルベースのページネーションを使う

カーソルベースのページネーションは、オフセットベースのページネーションと比較すると、
いい感じでより効率的です。
データ量が多くなってきた時やNoSQLデータベースのストレージでは特に顕著です。

カーソルベースのページネーションを選択する前に、次のトレードオフを検討しておきましょう。

* 使い勝手とフレームワークのサポート
** オフセットベースのページネーションはカーソルベースよりもよく知られており、フレームワークがサポートしていたり、APIクライアントで簡単に使えたりする
* ユースケース: とあるページへジャンプする
** (100ページ中の51ページのように) 特定のページにジャンプするようなユースケースは、カーソルベースでは実現できない
* データの変更は結果セットのページに異常を引き起こす可能性がある
** オフセットベースのページネーションは、ページ遷移の間に更新や削除がされると、結果の重複やロストを引き起こす可能性がある。
** カーソルベースのページネーションを使うときは、2つのページを取得する間にカーソルの指し示すエンティティの削除がおこなわれると、ページングを継続することはできない。
* パフォーマンスの考慮 - オフセットベースのページネーションを使ったサーバ処理は効率的に実行するのが難しい
** データベースのメインメモリにデータが存在しない場合は特に、コストの高い処理になる。
** 共有データベースかNoSQLか?
* カーソルベースのナビゲーションは、結果の総件数が必要だったり、後方へのページネーションをサポートする必要がある場合には実現できないかもしれません。

さらには以下の文書もあります:

* https://dev.twitter.com/rest/public/timelines[Twitter]
* http://use-the-index-luke.com/no-offset[Use the Index, Luke]
* https://www.citusdata.com/blog/1872-joe-nelson/409-five-ways-paginate-postgres-basic-exotic[Paging
in PostgreSQL]

[#161]
== {MAY} 適用可能なところではページネーションリンクを使う

* <<163,HATEOS>>を実装したAPIは、コレクション内でページネーションするために、<<165,simplified hypertext controls>>を使ってもよい

これらのコレクションは現在のページの項目を保持するために、`items`属性をもつべきです。
コレクションは必要ならば自身や現在のページについてのメタデータ(例えば`index`や`page_size`)を付加してもよいです。

明確な必要性がない限り、APIに総件数をもたせるのは避けるべきです。
総件数を取得するがために、フルスキャンを引き起こす複雑なクエリやフィルタを発行することになり
性能問題を引き起こすことがよくあるためです
(例えば、カウントとるためにすべての要素をスキャンする必要があります)。
これはAPIの実装の詳細に踏み込んだ話ですが、あなたの能力と、カウント機能を提供することとを
よく考えるのは重要なことです

もしコレクションが他のリソースへのリンクから構成されていれば、
コレクションの名前は、
http://www.iana.org/assignments/link-relations/link-relations.xml[IANA
IANAにLink Relationsとして登録されたもの]にするべきです。ただし複数形にしましょう。

例えば、"記事"のサービスは、`authors`へのハイパーリンクのコレクションを以下のように表現できます。

[source,json]
----
{
  "self": "https://.../articles/xyz/authors/",
  "index": 0,
  "page_size": 5,
  "items": [
    {
      "href": "https://...",
      "id": "123e4567-e89b-12d3-a456-426655440000",
      "name": "Kent Beck"
    },
    {
      "href": "https://...",
      "id": "987e2343-e89b-12d3-a456-426655440000",
      "name": "Mike Beedle"
    },
    ...
  ],
  "first": "https://...",
  "next": "https://...",
  "prev": "https://...",
  "last": "https://..."
}
----
