[[pagination]]
= ページネーション

[#159]
== {MUST} ページネーションをサポートする

リストデータへのアクセスは、クライアントサイドの一括処理と繰り返し操作のために、ページネーションをサポートしなければなりません。これは数百エントリ以上の(になる可能性のある)リストすべてにあてはまります。

2つのページネーションのテクニックがあります。

* http://developer.infoconnect.com/paging-results-limit-and-offset[Limit/Offsetベース]: 最初のページエントリをオフセット数値で特定する
* https://dev.twitter.com/overview/api/cursoring[カーソルベース] — またの名を
キーベース — ページネーション: 単一のキー要素で最初のページエントリを特定する
(https://developers.facebook.com/docs/graph-api/using-graph-api/v2.4#paging[Facebookのガイド]も見てください)

The technical conception of pagination should also consider user
experience related issues. As mentioned in this
https://www.smashingmagazine.com/2016/03/pagination-infinite-scrolling-load-more-buttons/[article],
jumping to a specific page is far less used than navigation via
next/previous page links. This favours cursor-based over offset-based
pagination.

[#160]
== {SHOULD} Offsetベースのページネーションを避け、カーソルベースのページネーションを使う

カーソルベースのページネーションは、オフセットベースのページネーションと比較すると、
いい感じでより効率的です。
データ量が多くなってきた時やNoSQLデータベースのストレージでは特に顕著です。

カーソルベースのページネーションを選択する前に、次のトレードオフを検討しておきましょう。

* 使い勝手とフレームワークのサポート
** オフセットベースのページネーションはカーソルベースよりもよく知られており、フレームワークがサポートしていたり、APIクライアントで簡単に使えたりする
* ユースケース: とあるページへジャンプする
** (100ページ中の51ページのように) 特定のページにジャンプするようなユースケースは、カーソルベースでは実現できない
* Variability of data may lead to anomalies in result pages
** Offset-based pagination may create duplicates or lead to missing
entries if rows are inserted or deleted between two subsequent paging
requests.
** When using cursor-based pagination, paging cannot continue when the
cursor entry has been deleted while fetching two pages
* Performance considerations - efficient server-side processing using
offset-based pagination is hardly feasible for:
** Higher data list volumes, especially if they do not reside in the
database’s main memory
** Sharded or NoSQL databases
* Cursor-based navigation may not work if you need the total count of
results and / or backward iteration support

Further reading:

* https://dev.twitter.com/rest/public/timelines[Twitter]
* http://use-the-index-luke.com/no-offset[Use the Index, Luke]
* https://www.citusdata.com/blog/1872-joe-nelson/409-five-ways-paginate-postgres-basic-exotic[Paging
in PostgreSQL]

[#161]
== {MAY} 適用可能なところではページネーションリンクを使う

* <<163,HATEOS>>を実装したAPIは、コレクション内でページネーションするために、<<165,simplified hypertext controls>>を使ってもよい

これらのコレクションは現在のページの項目を保持するために、`items`属性をもつべきです。
コレクションは必要ならば自身や現在のページについてのメタデータ(例えば`index`や`page_size`)を付加してもよいです。

明確な必要性がない限り、APIに総件数をもたせるのは避けるべきです。
総件数を取得するがために、フルスキャンを引き起こす複雑なクエリやフィルタを発行することになり
性能問題を引き起こすことがよくあるためです
(例えば、カウントとるためにすべての要素をスキャンする必要があります)。
これはAPIの実装の詳細に踏み込んだ話ですが、あなたの能力と、カウント機能を提供することとを
よく考えるのは重要なことです

もしコレクションが他のリソースへのリンクから構成されていれば、
コレクションの名前は、
http://www.iana.org/assignments/link-relations/link-relations.xml[IANA
IANAにLink Relationsとして登録されたもの]にするべきです。ただし複数形にしましょう。

例えば、"記事"のサービスは、`authors`へのハイパーリンクのコレクションを以下のように表現できます。

[source,json]
----
{
  "self": "https://.../articles/xyz/authors/",
  "index": 0,
  "page_size": 5,
  "items": [
    {
      "href": "https://...",
      "id": "123e4567-e89b-12d3-a456-426655440000",
      "name": "Kent Beck"
    },
    {
      "href": "https://...",
      "id": "987e2343-e89b-12d3-a456-426655440000",
      "name": "Mike Beedle"
    },
    ...
  ],
  "first": "https://...",
  "next": "https://...",
  "prev": "https://...",
  "last": "https://..."
}
----
