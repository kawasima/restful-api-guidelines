[[common-headers]]
= 共通のヘッダ

このセクションでは私たちが毎日使う中で疑問に思ったり、あまり知られてないけれど
特定の状況では役に立ったりするいくつかのヘッダについて記述します。

[#178]
== {MUST} 正しいContentヘッダを使う

Contentやエンティティに関するヘッダには、`Content-`のプレフィクスが付いています。
これらにはメッセージボディの内容に関することが書かれていて、HTTPリクエストとレスポンスの両方で使用されます。
共通的に使われるContentヘッダは次のようなものですが、その限りではありません。

* https://tools.ietf.org/html/rfc6266[`Content-Disposition`] はファイルとして
保存されることを意図したり、そのときのデフォルトのファイル名を与えるのに使う。
* https://tools.ietf.org/html/rfc7231#section-3.1.2.2[`Content-Encoding`]
はContentに適用される圧縮/暗号アルゴリズムを示す。
* https://tools.ietf.org/html/rfc7230#section-3.3.2[`Content-Length`]
はContentの長さをbyte長で示す。
* https://tools.ietf.org/html/rfc7231#section-3.1.3.2[`Content-Language`]
indicates that the body is meant for people literate in some human
language(s).
* https://tools.ietf.org/html/rfc7231#section-3.1.4.2[`Content-Location`]
はボディが別の場所にあることを示す
(<<179>> により詳細があります)。
* https://tools.ietf.org/html/rfc7231#section-3.1.1.5[`Content-Type`]
は、ボディのメディアタイプを示す。

[#133]
== {MAY} 標準のヘッダを使う

http://en.wikipedia.org/wiki/List_of_HTTP_header_fields[このリスト]
を使い、OpenAPI定義にサポートするヘッダを記述します。

[#179]
== {MAY} Content-Location ヘッダを使う

Content-Location ヘッダは _任意_ であり、成功した書き込み操作(PUT, POST, PATCH)や読み込み操作(GET, HEAD)
で使われ、キャッシュ位置を示したり、リソースの実際の場所を受信者に通知したりします。
これによりクライアントはリソースを識別し、このヘッダの付いたレスポンスを受け取ったらローカルコピーを
更新することができるのです。

Content-Locationヘッダは、次のユースケースを実現するのに使われます。

* GETやHEADで、リクエストされたURIとは異なる場所が、
返されるリソースはコンテントネゴシエーションに依存したものであったり、リソース固有の識別子を与えることを
示すのに使われる。
* PUTやPATCHでは、リクエストされたURIと同一の場所を指し、
返却されたリソースが、新しく生成/更新されたリソースの現在の表現であることを明示するのに使われまる。
* POSTやDELETEでは、
リクエストされたアクションに対するレスポンスに、ステータスレポートリソースが含まれることを示すのに使われる。

*注意*: Content-Locationヘッダを使用する際には、Content-Typeヘッダも正しく
設定しなければならない。例えば、以下のように。

[source,http]
----
GET /products/123/images HTTP/1.1

HTTP/1.1 200 OK
Content-Type: image/png
Content-Location: /products/123/images?format=raw
----

[#180]
== {SHOULD} Content-Locationの代わりにLocationヘッダを使う

セマンティクスやキャッシュに関して、Content-Locationを正しく使うのは
難しいので、私たちはContent-Location の使用を _推奨していません_ 。
たいていの場合、Content-Location特有の曖昧さや複雑さに悩まされる代わりに、
Locationヘッダを使うことで、クライアントにリソースの場所を直接知らせることで十分です。

RFC 7231により詳細があります。
* https://tools.ietf.org/html/rfc7231#section-7.1.2[7.1.2 Location]
* https://tools.ietf.org/html/rfc7231#section-3.1.4.2[3.1.4.2
Content-Location]

[#181]
== {MAY} Preferヘッダを使うUse the Prefer header to indicate processing preferences

`Prefer`ヘッダは https://tools.ietf.org/html/rfc7240[RFC7240]
で定義されており、クライアントがサーバの振る舞いをリクエスト
The `Prefer` header defined in
https://tools.ietf.org/html/rfc7240[RFC7240] allows clients to request
processing behaviors from servers.
https://tools.ietf.org/html/rfc7240[RFC7240] では多くのプリファレンスが
事前定義されていて拡張も可能です。
Prefer ヘッダのサポートは、任意でありAPI設計の裁量次第ですが、
既存のインターネット標準と同様に、独自の"X-"ヘッダを定義して処理することをおすすめします。

`Prefer` ヘッダはAPI定義に次のように定義します。

[source,yaml]
----
Prefer:
  name: Prefer
  description: |
    The RFC7240 Prefer header indicates that particular server
    behaviors are preferred by the client but are not required
    for successful completion of the request.
    # (indicate the preferences supported by the API)

  in: header
  type: string
  required: false
----

`Prefer` をサポートするAPIは、 これまた
https://tools.ietf.org/html/rfc7240[RFC7240]
で定義された `Preference-Applied` ヘッダを返すかもしれません。
これはプリファレンスが適用されたかどうかを指し示すのに使われます。

[#182]
== {MAY} If-Match/If-None-MatchヘッダともにEtagを使う

When creating or updating resources it may be necessary to expose
conflicts and to prevent the 'lost update' or 'initially created' problem.
Following https://tools.ietf.org/html/rfc7232[RFC 7232 "HTTP: Conditional Requests"]
this can be best accomplished by using the
https://tools.ietf.org/html/rfc7232#section-2.3[`ETag`] header together
with the https://tools.ietf.org/html/rfc7232#section-3.1[`If-Match`] or
https://tools.ietf.org/html/rfc7232#section-3.2[`If-None-Match`] conditional header. The
contents of an `ETag: <entity-tag>` header is either (a) a hash of the
response body, (b) a hash of the last modified field of the entity, or
(c) a version number or identifier of the entity version.

To expose conflicts between concurrent update operations via PUT, POST,
or PATCH, the `If-Match: <entity-tag>` header can be used to force the
server to check whether the version of the updated entity is conforming
to the requested `<entity-tag>`. If no matching entity is found, the
operation is supposed a to respond with status code 412 - precondition
failed.

Beside other use cases, the `If-None-Match:` header with parameter `*`
can be used in a similar way to expose conflicts in resource creation.
If any matching entity is found, the operation is supposed a to respond
with status code 412 - precondition failed.

The `ETag`, `If-Match`, and `If-None-Match` headers can be defined as
follows in the API definition:

[source,yaml]
----
Etag:
  name: Etag
  description: |
    The RFC7232 ETag header field in a response provides the current entity-
    tag for the selected resource. An entity-tag is an opaque identifier for
    different versions of a resource over time, regardless whether multiple
    versions are valid at the same time. An entity-tag consists of an opaque
    quoted string, possibly prefixed by a weakness indicator.

  in: header
  type: string
  required: false
  example: W/"xy", "5", "7da7a728-f910-11e6-942a-68f728c1ba70"

IfMatch:
  name: If-Match
  description: |
    The RFC7232 If-Match header field in a request requires the server to
    only operate on the resource that matches at least one of the provided
    entity-tags. This allows clients express a precondition that prevent
    the method from being applied if there have been any changes to the
    resource.

  in: header
  type: string
  required: false
  example:  "5", "7da7a728-f910-11e6-942a-68f728c1ba70"

IfNoneMatch:
  name: If-None-Match
  description: |
    The RFC7232 If-None-Match header field in a request requires the server
    to only operate on the resource if it does not match any of the provided
    entity-tags. If the provided entity-tag is `*`, it is required that the
    resource does not exist at all.

  in: header
  type: string
  required: false
  example: "7da7a728-f910-11e6-942a-68f728c1ba70", *
----

別のアプローチについての議論は、<<optimistic-locking>> セクションも参照ください。
