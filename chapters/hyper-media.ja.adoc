[[hypermedia]]
= ハイパーメディア

[#162]
== {MUST} REST成熟モデル2を使う

私たちは
http://martinfowler.com/articles/richardsonMaturityModel.html#level2[REST
成熟度レベル2] のイケてる実装を目指します。
そうすることでHTTP動詞とステータスコードをフル活用した、リソース指向APIを構築できるようになるからです。
これらのガイドラインを通じて、これは多くのルールによって表現されています。

* <<138>>
* <<141>>
* <<148>>
* <<150>>

これはHATEOASではありませんが、以下に示すルールで記述されるように、
APIに正しいリンク関連を設計することにとらわれるべきではありません。

[#163]
== {MAY} REST成熟モデル3を使う - HATEOAS

私たちは基本的には、
http://martinfowler.com/articles/richardsonMaturityModel.html#level3[REST
成熟レベル3] を実装すことはおすすめしません。
HATEOASは、クライアントとサーバのREST APIを通じたやりとりしたり、
私たちのeコマースのSaaSプラットフォームの一部として複雑な業務機能を提供したりする、
私たちのSOA文脈においては、価値のない複雑さをAPIにもたらします。

私たち主な関心は、HATEOASのもたらす利点にあります。
(詳細な議論は https://www.infoq.com/news/2014/03/rest-at-odds-with-web-apis[RESTistential
Crisis over Hypermedia APIs] や https://jeffknupp.com/blog/2014/06/03/why-i-hate-hateoas/[Why I Hate HATEOAS] 、を参照ください)

* 私たちは標準仕様言語でコード外に明示的にAPIを定義して、<<100,APIファーストの原則>>にしたがいます。
HATEOASはSOAクライアントエンジニアにとって、APIの自己記述性にはあまり価値を感じません:
クライアントエンジニアは、APIリファレンス定義に、(リソースの状態に依存した)必要なリンクや使い方の記述を見ることができるのですから。
* 一般的なHATEOASクライアントは、APIについての前提知識を必要とせず、与えられたハイパーメディア情報に
基づいたAPIの機能を探すことができるものですが、これは理論的な概念で、
私たちは実際に動いてるのを見たことがないし、私たちのSOA機構にフィットしません。
またOpenAPIの記述フォーマット(とそのツール)は、HATEOASのサポートも十分ではありません。
* 実際、HATEOASに似た(HALやJSON APIのような)仕様も、URLエンドポイントやHTTPメソッドの性質から
情報を取り出すことによって、APIナビゲーションをサポートします。
したがってハイパーメディアはドメインモデルが徐々に変化していくときには、
結局クライアントは手動での変更が余儀なくされるのです。
* ハイパーメディアは人間にとっては意味のあるものですが、SOAクライアントにとってはそうでもありません。
私たちは、SOAクライアントがサービスドメイン境界にいるフロントエンドや人間に価値を届けることができる
ユースケースを想定しているのです。
* ハイパーメディアは、APIクライアントが'discovering'を使わずに、ショートカットを実装したり、
直接対象のリソースをターゲットにすることを防げません。

しかし、私たちはHATEOASを禁止するわけではありません。
その制限を理解し、複雑さを代償としてもより価値のある利用シーンがあるのであれば、HATEOASを使ってもかまいません。

[#217]
== {MUST} 絶対URIを使う

Links to other resource must always use full, absolute URI.

*Motivation*: Exposing any form of relative URI (no matter if the relative
URI uses an absolute or relative path) introduces avoidable client side
complexity. It also requires clarity on the base URI, which might not be given
when using features like embedding subresources. The primary advantage
of non-absolute URI is reduction of the payload size, which is better
achievable by following the recommendation to use <<156,gzip compression>>

[#164]
== {MUST} 共通のハイパーテキストコントロールを使う

When embedding links to other resources into representations you must
use the common hypertext control object. It contains at least one
attribute:

* `href`: The URI of the resource the hypertext control is linking to.
All our API are using HTTP(s) as URI scheme.

In API that contain any hypertext controls, the attribute name `href` is
reserved for usage within hypertext controls.

The schema for hypertext controls can be derived from this model:

[source,yaml]
----
HttpLink:
  description: A base type of objects representing links to resources.
  type: object
  properties:
    href:
      description: Any URI that is using http or https protocol
      type: string
      format: uri
  required: [ "href" ]
----

The name of an attribute holding such a `HttpLink` object specifies the
relation between the object that contains the link and the linked
resource. Implementations should use names from the
http://www.iana.org/assignments/link-relations/link-relations.xhtml[IANA
Link Relation Registry] whenever appropriate. As IANA link relation
names use hyphen-case notation, while this guide enforces snake_case
notation for attribute names, hyphens in IANA names have to be replaced
with underscores (e.g. the IANA link relation type `version-history`
would become the attribute `version_history`)

Specific link objects may extend the basic link type with additional
attributes, to give additional information related to the linked
resource or the relationship between the source resource and the linked
one.

E.g. a service providing "Person" resources could model a person who is
married with some other person with a hypertext control that contains
attributes which describe the other person (`id`, `name`) but also the
relationship "spouse" between the two persons (`since`):

[source,json]
----
{
  "id": "446f9876-e89b-12d3-a456-426655440000",
  "name": "Peter Mustermann",
  "spouse": {
    "href": "https://...",
    "since": "1996-12-19",
    "id": "123e4567-e89b-12d3-a456-426655440000",
    "name": "Linda Mustermann"
  }
}
----

Hypertext controls are allowed anywhere within a JSON model. While this
specification would allow
http://stateless.co/hal_specification.html[HAL], we actually don't
recommend/enforce the usage of HAL anymore as the structural separation
of meta-data and data creates more harm than value to the
understandability and usability of an API.

[#165]
== {SHOULD} Use Simple Hypertext Controls for Pagination and Self-References

Hypertext controls for pagination inside collections and self-references
should use a simple URI value in combination with their corresponding
http://www.iana.org/assignments/link-relations/link-relations.xml[link
relations] (`next`, `prev`, `first`, `last`, `self`) instead of the
extensible common hypertext control

See <<pagination>> for information how to best represent paginateable collections.

[#166]
== {MUST} Not Use Link Headers with JSON entities

We don't allow the use of the
http://tools.ietf.org/html/rfc5988#section-5[`Link` Header defined by
RFC 5988] in conjunction with JSON media types. We prefer links directly
embedded in JSON payloads to the uncommon link header syntax.
