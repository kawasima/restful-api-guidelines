[[resources]]
= リソース

[#138]
== {MUST} アクションを避ける — リソースについて考える

RESTはリソースにまつわるもが全てです。したがって、Webサービスとドメインエンティティがどうやり取りするか、標準のHTTPメソッドを使ってAPIをどうモデル化するか、が関心事となります。
例えば、記事の編集するアプリケーションで、同時に1人のユーザしか編集できないように明示的にロックをしたいとします。「ロックする」というアクションの代わりに、「記事のロック」をPUTまたはPOSTで生成するようにします。

リクエスト:

[source,http]
----
PUT /article-locks/{article-id}
----

これは記事のロックを閲覧したり、フィルタリングしたりするサービスがすでに存在していると、追加のメリットとなります。

[#139]
== {SHOULD} 完全な業務プロセスをモデル化する

APIはプロセスを表現したすべてのリソースを含んだ、完全な業務プロセスを含めるべきです。
そうすることによって、クライアントが業務プロセスを理解し、業務プロセスの一貫した設計を推進し、ドキュメントと実装の観点から相乗効果が得られるようになり、API間の暗黙的で見えにくい依存関係を消すことができます。

おまけに、業務ロジックをクライアントサイドにシフトしてしまう「データベースの薄いラッパーAPI」を避ける効果もあります。

[#140]
== {SHOULD} 「有用な」リソースを定義する

リソースはすべてのクライアントのユースケースの90%をカバーするようにしよう、というのが経験則としてあります。
「有用な」リソースは情報を必要なだけ多く含むと同時に、できるだけ小さくあるべきです。
残りの10%をサポートするよい方法は、クライアントがその必要性に応じてフィルタリングしたり<<157, embedding>>できるようにすることです。

[#141]
== {MUST} URLに動詞を入れない

APIはリソースを記述します。HTTPメソッドの中にのみ、振る舞いが現れます。
したがって、URLは名詞だけを使うようにしてください。
振る舞い(動詞)を考える代わりに、郵便ポストにメッセージを投函することを考えるようにします。
例えば、URLに_キャンセル_という動詞をもたせる代わりに、「注文をキャンセルする」というメッセージを、
サーバの_キャンセル郵便ポスト_に届ける、と考えるのです。

[#142]
== {MUST} ドメイン固有のリソース名を付ける

APIリソースはアプリケーションのドメインモデルの要素を表現するものです。
リソース名にドメイン固有の命名法を使うことは、開発者がリソースのもつ機能や基本的な意味を理解するのに役立ちますし、
API定義の以外にドキュメントをたくさん書かなきゃいけない必要性を軽減できます。
例えば「sales-order-items」は単に「order-items」とするよりも、その対象をはっきりと指し示しているのでより良いものといえます。
同様に「items」とするのは、一般的過ぎます。

[#143]
== {MUST} パスセグメントによってリソースとサブリソースを識別できるようにする

いくつかのAPIリソースは、サブリソースを含んだり参照したりするかもしれません。
トップレベルのリソースではないEmbeddedサブリソースは、より高次のリソースの一部であり、
そのスコープの外からは使われないものです。
サブリソースはパスセグメントに含まれた名前と識別子によって参照されます。

使い勝手を向上させるため、パスセグメントそれぞれがリソースやリソースの集合を正しく指すような、
直感的に理解できるURLを目指すべきです。
例えば`/customers/12ev123bv12v/addresses/DE_100100101`はAPIのパスとしてあったとき、
`/customers/12ev123bv12v/addresses`, `/customers/12ev123bv12v`や`/customers`も、
原則的には妥当なパスでなくてはなりません。

基本形のURL構造:

[source,http]
----
/{resources}/[resource-id]/{sub-resources}/[sub-resource-id]
/{resources}/[partial-id-1][separator][partial-id-2]
----

例:

[source,http]
----
/carts/1681e6b88ec1/items
/carts/1681e6b88ec1/items/1
/customers/12ev123bv12v/addresses/DE_100100101
----

[#144]
== {SHOULD} 必要なときだけUUIDを使う

IDの生成はハイトラフィックでリアルタイム性の要求されるようなユースケースでは、
スケールの点で問題を引き起こすことがあります。
UUIDは分散非協調な方法で競合することなく、かつ他にサーバ通信の必要もなく生成可能なので、この問題の解となりえます。

しかし、UUIDにはいくつかのデメリットがあります。

* 意味のない人工的なキーである。例えば、
* pure technical key without meaning; not ready for naming or name scope
conventions that might be helpful for pragmatic reasons, e.g. we learned
to use names for product attributes, instead of UUIDs
* 使いづらい
* 人間には覚えられないし、それを使ってコミュニケーションできない
* デバッグやログ解析に使いづらい
* かなり長い: 読めるキャラクタ形式にすると36文字にもなり、メモリや帯域の圧迫の原因となる。
* 生成順に並べることができない。
* レガシーなIDの後方互換サポートと競合するかもしれない

UUIDはID生成がボトルネックとなるようなときまで避けるべきです。
代わりに、例えば(IDリソースへのPOSTとエンティティリソースへの冪等なPUT)。

Instead, for instance, server side support with id generation can be
preferred (POST on id resource, followed by idempotent PUT on entity
resource). Usage of UUIDs is especially discouraged as primary keys of
master and configuration data, like brand-ids or attribute-ids which
have low id volume but widespread steering functionality.

どんな場合も、IDには数値型よりも文字列型を常に使うべきです。
これはIDの体系が進化していくときに、自由度が高くなるからです。
したがって、UUIDはformatプロパティで修飾してはいけません。

ヒント: よくランダムUUIDが使われます。
https://tools.ietf.org/html/rfc4122[RFC 4122]のUUID バージョン4をみてください。
UUID バージョン1は、タイムスタンプを元に作るけれども、生成順にソートはできない仕様です。
https://github.com/alizain/ulid[ULID] (Universally Unique
Lexicographically Sortable Identifier) はこの欠点をなくすように作られています。
生成時間でソートするページネーションのユースケースなどでは、UUIDの代わりにULIDが使えるでしょう。

[#145]
== {MAY} ネストURLを使う/使わないはよく考える

もしサブリソースがその親リソースにアクセス可能で、親リソースなしでは存在しえないものであったら、
ネストURL構造を検討しましょう。

例えば、以下のようなものです。

[source,http]
----
/carts/1681e6b88ec1/cart-items/1
----

しかし、リソースがそのユニークなIDによって直接アクセスされうるとしたら、
APIはトップレベルのリソースとして用意するべきです。

例えばカスタマは複数の販売注文をもちますが、販売注文にはユニークなIDがふってあって、
いくつかのサービスからは直接注文にアクセスするかもしれない場合です。

そのようなケースでは以下のようにします。

[source,http]
----
/customers/1681e6b88ec1
/sales-orders/5273gh3k525a
----

[#146]
== {SHOULD} Limit number of Resource types

サービスの開発・メンテナンスを続けていくためには、「機能分割」や「関心の分離」の設計原則にしたがい、
同一のAPI定義に異なる業務機能群を混ぜ込まないようにするべきです。
実際にAPIをつうじて機能提供されるリソースの種類は、その数に上限をもうけたほうがよいでしょう。


To keep maintenance and service evolution manageable, we should follow
"functional segmentation" and "separation of concern" design principles
and do not mix different business functionalities in same API
definition. In practice this means that the number of resource types
exposed via an API should be limited. In this context a resource type is
defined as a set of highly related resources such as a collection, its
members and any direct sub-resources.

例えばリソースは1つの
For example, the resources below would be counted as three resource
types, one for customers, one for the addresses, and one for the
customers' related addresses:

[source,http]
----
/customers
/customers/{id}
/customers/{id}/preferences
/customers/{id}/addresses
/customers/{id}/addresses/{addr}
/addresses
/addresses/{addr}
----

* 追加の識別子なしでカスタマと1対1の関係をもつので、`/customers`リソースの一部として`/customers/{id}/preferences`を考えます。
* `/customers`と`/customers/{id}/addresses`とは、
Note that:

* We consider `/customers/{id}/preferences` part of the `/customers`
resource type because it has a one-to-one relation to the customer
without an additional identifier.
* We consider `/customers` and `/customers/{id}/addresses` as separate
resource types because `/customers/{id}/addresses/{addr}` also exists
with an additional identifier for the address.
* We consider `/addresses` and `/customers/{id}/addresses` as separate
resource types because there's no reliable way to be sure they are the
same.

この定義があれば、経験的にリソースのタイプは4〜8より多くなることはないと思います。
より多くのリソースを必要とする複雑な業務ドメインでは例外があるかもしれませんが、
その際はAPIを分類することによって、サブドメインに分割できないかをまず検討するべきです。

そうはいっても1つのAPIは、利用者が業務フローを理解できるように完全な業務プロセスをモデル化し、
必要なリソースすべてを揃えたものであるべきなのは、お忘れなく。

[#147]
== {SHOULD} サブリソースのレベルの深さを制限する

There are main resources (with root url paths) and sub-resources (or
“nested” resources with non-root urls paths). Use sub-resources if their
life cycle is (loosely) coupled to the main resource, i.e. the main
resource works as collection resource of the subresource entities. You
should use <= 3 sub-resource (nesting) levels -- more levels increase
API complexity and url path length. (Remember, some popular web browsers
do not support URLs of more than 2000 characters)
