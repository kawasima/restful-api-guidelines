[[http-status-codes-and-errors]]
= HTTPステータスコードとエラー

[#151]
== {MUST} 成功とエラーレスポンスを規定する

APIは機能、業務の観点で定義され、実装の観点からは切り離され抽象化しなければなりません。
成功と失敗のレスポンスは、APIが正しく使われるために必要不可欠な部分です。

だからAPI仕様においては、**すべての**成功とサービス固有のエラーレスポンスを定義しなければなりません。
両者ともインタフェース定義の一部であり、サービスクライアントが標準だけでなく例外も、
正しく扱うための重要な情報を提供するものです。

**ヒント:** たいていの場合、すべての技術的なエラー、特にサービスプロバイダに制御されないようなものを、
ドキュメント化するのは役に立ちません。
レスポンスコードがアプリケーション固有の機能の意味を伝えないか、または
追加の説明を必要とするような標準でない使われ方をする限りは、
複数のエラーレスポンス仕様は、次のパターンを用いて組み合わせることができます。

[source,yaml]
----
responses:
  ...
  default:
    description: error occurred - see status code and problem object for more information.
    schema:
      $ref: 'https://zalando.github.io/problem/schema.yaml#/Problem'
----

API designers should also think about a **troubleshooting board** as part of the
associated online API documentation. It provides information and handling
guidance on application-specific errors and is referenced via links from the
API specification. This can reduce service support tasks and contribute to
service client and provider performance.


[#150]
== {MUST} 標準のHTTPステータスコードを使う

標準のHTTPステータスコードのみを使い、その意味に沿うように一貫性をもった設計をしなければなりません。
どうかHTTPステータスコードを新たに発明しないようにしてください。

RFCの標準では ~60 の異なるHTTPステータスコードと同時にその意味も定義されていてます。
(主に https://tools.ietf.org/html/rfc7231#section-6[RFC7231] と
https://tools.ietf.org/html/rfc6585[RFC-6585])
— そして
https://tools.ietf.org/html/draft-tbray-http-legally-restricted-status-05[draft
legally-restricted-status]
のように新しいものもあります。
すべてのエラーコードは
https://en.wikipedia.org/wiki/List_of_HTTP_status_codes[Wikipedia]
か https://httpstatuses.com/ で '非公式なコード'(NginxのようなWebサーバで使われるもの)を含んだものを
見ることができます。

以下によく共通で使う(RFC標準と整合性ある)HTTPステータスコードを、理解の助けになるよう一覧にしました。
ここに載ってないHTTPステータスコードを使っても良いですが、
その場合、API定義に明示しなくてはなりません。
ここに載ってるコードを使う限りは、そうする必要はありません。
一貫性のない定義をしてしまうリスクは低いし、常識をドキュメントに書きすぎると可読性が下がるからです。

[[success-codes]]
=== 成功コード

[cols="10%,70%,20%",options="header",]
|=======================================================================
|Code |Meaning |Methods
|200 |OK - 標準の成功レスポンス |All

|201 |Created - エンティティが正常に作成されたこととを示す。空のレスポンス
でも作成されたリソースを返してもよい。がそのリソースのURLをLocationヘッダにセットする。
(より詳細は <<common-headers>> 参照)
_常に_ Locationヘッダをセットすること。 |POST, PUT

|202 |Accepted - リクエストは成功し非同期で処理されている。
|POST, PUT, DELETE, PATCH

|204 |No content - レスポンスボディがない。 |PUT, DELETE, PATCH

|207 |Multi-Status - バッチ/バルクリクエストで、レスポンスボディは複数の
ステータスを含んでいる。<<152>> 参照
|POST
|=======================================================================

[[redirection-codes]]
=== リダイレクトのコード

[cols="10%,70%,20%",options="header",]
|=======================================================================
|Code |Meaning |Methods
|301 |Moved Permanently - 以後のリクエストはすべて与えられたURIに直接送るようにすべき。
|All

|303 |See Other - GETメソッドを使って別のURIへリクエストを送ってくれ。
|PATCH, POST, PUT, DELETE

|304 |Not Modified - If-Modified-Since や If-None-Match ヘッダで送られた
日付やバージョンから、リソースは何も変更されていない。
|GET
|=======================================================================

[[client-side-error-codes]]
=== クライアントサイドのエラーコード

[cols="10%,70%,20%",options="header",]
|=======================================================================
|Code |Meaning |Methods
|400 |Bad request - 一般的な / 未知のエラー。入力のペイロードが業務ロジックバリデーションで
エラーになったときにも送出される。
|All

|401 |Unauthorized - ユーザはログインしなければならない。(“Unauthenticated”の意) |All

|403 |Forbidden - ユーザはこのリソースのアクセス権限がない。|All

|404 |Not found - リソースが見つからない。 |All

|405 |Method Not Allowed - メソッドがサポートされていない。OPTIONSで調べることができる。 |All

|406 |Not Acceptable - リクエストで送られたAcceptヘッダにしたがったレスポンスを返すことができない。
|All

|408 |Request timeout - リソース待ちでサーバがタイムアウトした。
|All

|409 |Conflict - リクエストは競合が発生したために完遂できなかった。例えば2つのクライアントが同じリソースを作成しようとしたり、同時に整合性の保てない更新要求が発生するようなケース。
|POST, PUT, DELETE, PATCH

|410 |Gone - リソースがもう存在しない。例えば、意図して削除されたリソースにアクセスしたケース。|All

|412 |Precondition Failed - 条件に合わないリクエストがされた。例えばIf-Matchを満たさないケース。
楽観ロックで使われる。
|PUT, DELETE, PATCH

|415 |Unsupported Media Type - 例えばクライアントがContent-Typeなしでリクエストボディを送っていたケース
content type |POST, PUT, DELETE, PATCH

|423 |Locked - 悲観ロック。例えば、処理中。 |PUT, DELETE,
PATCH

|428 |Precondition Required - サーバは条件付きリクエストを要求する。(e.g. to make sure that the “lost update problem” is avoided). |All

|429 |Too many requests - クライアントが大量のリクエストを送ってきた。 <<153>> 参照。 |All
|=======================================================================

[[server-side-error-codes]]
=== サーバサイドのエラーコード

[cols="10%,70%,20%",options="header",]
|=======================================================================
|Code |Meaning |Methods
|500 |Internal Server Error - サーバで予期しないエラーが起きたことを示す。(クライアントのリトライは単純には行えない可能性があります)
|All

|501 |Not Implemented - サーバはリクエストを実行できない (暗に将来実行可能になることを指す)。
|All

|503 |Service Unavailable - サーバが(一時的に)利用できない (つまり高負荷のため)
 -- クライアントのリトライは単純には行えない可能性があります
|All
|=======================================================================

[#220]
== {MUST} もっとも状況にあったHTTPステータスコードを使う

処理結果やエラー状況を返すとき、もっとも適したHTTPステータスコードを使わねばなりません。

[#152]
== {MUST} Use Code 207 for Batch or Bulk Requests

Some APIs are required to provide either _batch_ or _bulk_ requests
using POST for performance reasons, i.e. for communication and
processing efficiency. In this case services may be in need to signal
multiple response codes for each part of an batch or bulk request. As
HTTP does not provide proper guidance for handling batch/bulk requests
and responses, we herewith define the following approach:

* A batch or bulk request *always* has to respond with HTTP status code
*207*, unless it encounters a generic or unexpected failure before
looking at individual parts.
* A batch or bulk response with status code 207 *always* returns a
multi-status object containing sufficient status and/or monitoring
information for each part of the batch or bulk request.
* A batch or bulk request may result in a status code 400/500, only if
the service encounters a failure before looking at individual parts or,
if an unanticipated failure occurs.

The before rules apply _even in the case_ that processing of all
individual part _fail_ or each part is executed _asynchronously_! They
are intended to allow clients to act on batch and bulk responses by
inspecting the individual results in a consistent way.

*Note*: while a _batch_ defines a collection of requests triggering
independent processes, a _bulk_ defines a collection of independent
resources created or updated together in one request. With respect to
response processing this distinction normally does not matter.

[#153]
== {MUST} レート制限のヘッダには429を使う Use Code 429 with Headers for Rate Limits

クライアントのリクエストレートをコントロールしたいAPIは、
http://tools.ietf.org/html/rfc6585['429 Too Many Requests']レスポンス
コードを使います。
もしクライアントがリクエストレートを越えたら、リクエストは実行されなくなります。
そのようなレスポンスは、クライアントにそのような追加の情報を知らせるために、
ヘッダをセットしなくてはなりません。その手段は次の2つがあります。

* https://tools.ietf.org/html/rfc7231#section-7.1.3['Retry-After'] ヘッダを
返す。
* Return a
https://tools.ietf.org/html/rfc7231#section-7.1.3['Retry-After'] header
indicating how long the client ought to wait before making a follow-up
request. The Retry-After header can contain a HTTP date value to retry
after or the number of seconds to delay. Either is acceptable but APIs
should prefer to use a delay in seconds.
* Return a trio of 'X-RateLimit' headers. These headers (described
below) allow a server to express a service level in the form of a number
of allowing requests within a given window of time and when the window
is reset.

The 'X-RateLimit' headers are:

* `X-RateLimit-Limit`: The maximum number of requests that the client is
allowed to make in this window.
* `X-RateLimit-Remaining`: The number of requests allowed in the current
window.
* `X-RateLimit-Reset`: The relative time in seconds when the rate limit
window will be reset.

The reason to allow both approaches is that APIs can have different
needs. Retry-After is often sufficient for general load handling and
request throttling scenarios and notably, does not strictly require the
concept of a calling entity such as a tenant or named account. In turn
this allows resource owners to minimise the amount of state they have to
carry with respect to client requests. The 'X-RateLimit' headers are
suitable for scenarios where clients are associated with pre-existing
account or tenancy structures. 'X-RateLimit' headers are generally
returned on every request and not just on a 429, which implies the
service implementing the API is carrying sufficient state to track the
number of requests made within a given window for each named entity.


[#176]
== {MUST} Problem JSONを使う

http://tools.ietf.org/html/rfc7807[RFC 7807] でProblem JSONオブジェクトと、
`application/problem+json` メディアタイプが定義されています。
処理中に発生したどんな問題も(適切なステータスコードとともに)これを使い、
クライアントサイドのエラー(4xx)か、サーバサイドのエラー(5xx)かに関わらず、
ステータスコードよりも詳細な情報を返すべきです。

Problem JSONオブジェクトのOpenAPIスキーマ定義は、
https://zalando.github.io/problem/schema.yaml[GitHub上]
にあります。

これを使って以下のように定義できます。

[source,yaml]
----
responses:
  503:
    description: Service Unavailable
    schema:
      $ref: 'https://zalando.github.io/problem/schema.yaml#/Problem'
----

もしAPIが追加のエラー詳細情報を返す必要があれば、
Problem JSONの拡張としてカスタムの型を定義することもできます。

**ヒント** (後方互換性のために):
このガイドラインの以前のバージョンでは(http://tools.ietf.org/html/rfc7807[RFC 7807] が
公開される前だったので)、
`application/x.problem+json` のメディアタイプを返すようにしていました。
この変更前に定義されたAPIサーバは、
クライアントが送る`Accept`ヘッダとエラーレスポンスの`Content-Type`ヘッダの
対応に注意しなければなりません。
またそのようなAPIのクライアントは、両方のメディアタイプを受け付け可能でなければなりません。

[#177]
== {MUST} スタックトレースを外に見せないようにする

スタックトレースには、APIの一部だけでなく、クライアントが依存すべきでない実装の詳細が含まれます。
さらにはスタックトレースは、パートナーやサードパーティが受け取ってはならない機微な情報を漏らしてしまう
可能性があるし、攻撃者に脆弱性についてのヒントを与えることにもなりかねません。
