[[api-naming]]
= APIの命名

[#129]
== {MUST} パスセグメントはハイフンで区切られた小文字を使う

例:

[source,http]
----
/shipment-orders/{shipment-order-id}
----

このルールは具体化されたパスセグメントに適用され、パスパラメータの名前は
この限りではありません。
例えば`{shipment_order_id}`は、パスパラメータとしてはOKです。

[#130]
== {MUST} クエリパラメータは、スネークケースを使う(決してキャメルケースにしない)

例:

[source]
----
customer_number, order_id, billing_address
----

[#132]
== {SHOULD} HTTPヘッダはハイフン区切りのパスカルケースにする

これは一貫性のためのルールです(他のほとんどのヘッダがこの規約にしたがっているためです)。
(ハイフンなしの)キャメルケースにするのは避けましょう。例外は「ID」のような共通の略語です。

例:

[source,http]
----
Accept-Encoding
Apply-To-Redirect-Ref
Disposition-Notification-Options
Original-Message-ID
----

参考: http://tools.ietf.org/html/rfc7230#page-22[HTTPヘッダは大文字・小文字を区別しない (RFC 7230)]


<<common-headers>> と <<proprietary-headers>> の章に、HTTPヘッダに関する
ガイダンスがもう少しあるので参照ください。

[#134]
== {MUST} リソース名は複数形にする

ふつうリソースインスタンスのコレクションが提供されます(すくなくともAPIは用意されるべきです)。
リソースがシングルトンである特別な場合が、カーディナリティ1のコレクションと考えます。

[#135]
== {MAY} 最初のパスセグメントに /api を付ける

たいていの場合、サービスによって提供されるすべてのリーソースは、公開APIの一部です。
それゆえにベースパスであるルート"/"は利用可能にしておくべきです。
もしサービスが非公開、内部APIをサポートしなきゃいけなくなったら、ベースパスとして"/api"を
付けておけば、公開APIと非公開APIのリソースを明確に分離しておくことができます。

[#136]
== {MUST} 末尾のスラッシュを避ける

末尾スラッシュに特定の意味をもたせてはなりません。リソースパスは
末尾にスラッシュがあろうがなかろうが、同じ結果を返さなければなりません。

[#137]
== {MAY} クエリストリングの規約を使う

もしソートやページネーション、フィルタ関数または他のアクションをサポートしたクエリを提供することになったら、
次に示す標準の命名規約にしたがってください。

* `q` — デフォルトのクエリパラメータ (つまりブラウザのタブ補完で使われる); そうでないものはskuのようなエンティティ特有の別名を持つべきである。
* `limit` — エンティティの数を制限する。ページネーションのセクションをみてください。ヒント: `size` を別のクエリ文字列として使うこともできます。
* `cursor` — キーベースのページのスタート地点。<<pagination>> セクション参照。
* `offset` — 数値のオフセットによるページのスタート地点。<<pagination>> セクション参照。
ヒント: limitとの組み合わせにおいては、offsetの代わりに `page` を使ってもよい。
* `sort` — ソートに使うフィールドをカンマで繋いだリスト。ソートの方向を指示するために、フィールドには + (昇順) または - (降順) のプレフィクスが付くことがある。例: /sales-orders?sort=+id
* `fields` — フィールドのサブセットのみを取得するため。<<157,_リソースフィールドのフィルタリングサポート_>> を参照ください。
* `embed` — エンティティの中身を展開する。 ( 記事エンティティの内部で、シルエットコードをシルエットオブジェクトに展開する). "展開"を正しく実装するのは難しいので、注意してやる必要がある。

[%hardbreaks]
