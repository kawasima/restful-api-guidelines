[[compatibility]]
= 互換性

[#106]
== {MUST} 後方互換性を崩してはならない

APIの変更は、すべての利用者の動作に影響がないようにおこなわなければなりません。
通常、利用者はAPIのリリースサイクルからは独立していて、安定性に注力しており、
付加価値をうまない変更は避けようとします。
APIはサービスプロバイダとサービスコンシューマの間の契約であり、一方の都合だけで
それを破棄することはできません。

それを実現するための2つの方法があります。

* 互換性拡張のルールにしたがう
* APIに新しいバージョンを導入し、古いバージョンもサポートする

私たちは互換性を維持したAPIの拡張を強く推奨し、バージョニングは最後の手段とします。(以下に示すルールをみてください <<113,113>>,<<114,114>> )
サービスプロバイダが従うガイドライン(<<107,rule 107>>) と コンシューマが従うガイドライン(<<108,rule 108>>) で、バージョニングなしに(ポステルの法則を胸に)互換性をたもった変更ができるようになります。

*注意:* 非互換性とは破壊的変更には違いがあります。非互換は変更とは、以下の互換性ルールを満たしていない変更です。
破壊的変更は非互換な変更を本番環境へデプロイすることです。したがって今動いているAPIコンシューマをも破壊することを意味します。
通常は、非互換の変更は本番環境にデプロイされたとき破壊的変更になりますが、どのAPIコンシューマにも影響を与えないのであれば、破壊的変更をせずに本番環境に非互換な変更をデプロイ可能です。(<<deprecation, Deprecation>> ガイドライン参照)

*ヒント:* 互換性の保証が"オンザワイヤー"(?)形式のためであることに注意してください。
API定義から生成されたバイナリまたはソースコードの互換性は、このルールの範疇ではありません。
もしクライアントの実装がAPI定義の新しいバージョンへ追従するために更新されるならば、コードの変更が必要だと予想されます。

[#107]
== {SHOULD} 互換性を維持した拡張をやろう

APIの設計者は後方互換性を維持しつつ、RESTful APIを進化させていくために、次のルールにしたがうべきです。

* 任意のフィールドのみ追加して、必須のフィールドは追加してはならない。
* フィールドの意味は決して変えてはならない (例えばcustomer-numberをcustomer-idに変更することは、両者はカスタマの一意キーとしての意味は異なるのでNG)
* サーバサイドのビジネスロジックでバリデーションしなきゃいけないような(複雑な)制約をもつ入力フィールド。バリデーションロジックは、より厳しくなる方向には変更してはいけません。すべての制約はdescriptionに明示します。
* 入力パラメータとして使われる列挙型の要素は、サーバが古い値も受け付けて正しくハンドリングできる場合のみ減らすことができる。出力パラメータとして使われる列挙型はいつでも減らすことはできる。
* 出力パラメータとして使われる列挙型は、クライアントがハンドリングできないかもしれないので追加してはならない。入力パラメータとして使われる列挙型はいつでも追加できる。
* 出力パラメータととして使用され将来の拡張も考えておきたい場合は、<<112,`x-extensible-enum`>>を使う。
明示的に値を上限なしリストと定義し、クライアントは新しい値には依存しない設計をしなければならない。
* URLを変更するときはリダイレクションをサポートする
(https://en.wikipedia.org/wiki/HTTP_301[301 Moved Permanently]).

[#108]
== {MUST} 互換性維持のAPI拡張でクラッシュしないクライアントを用意する

サービスクライアントにはロバストネスの原則を適用すべきです。

* APIリクエストと入力として渡すデータは保守的に。例えば最大長が定義されていないからといって、数メガバイトの文字列を渡すようなことは避けよう。
* APIレスポンスのデータの処理や読み込みについては特に寛容に。

サービスクライアントはサービスプロバイダの互換性あるAPI拡張に対して、準備しておかなければなりません。

* ペイロードの未知のフィールドに対して寛容でなければならない。続くPUTリクエストで必要とされるならば、ペイロードから削除せず新しいフィールドは無視する。 (ファウラーの
http://martinfowler.com/bliki/TolerantReader.html["TolerantReader"]
の記事もみてください)
* 未知の値について予測できなくても、デフォルトの振る舞いが与えられていても、<<112,`x-extensible-enum`>>の戻りパラメータは、新しい値を含んでいると思って設計する
* エンドポイントの定義に明記されてないHTTPステータスコードがきても、ハンドリングできるようにしておく。
またステータスコードは拡張可能なことにも注意しよう。デフォルトのハンドリングは、関連するx00コードをどう扱うかである。
(https://tools.ietf.org/html/rfc7231#section-6[RFC7231 Section 6] も見てください)
* サーバがHTTPステータス https://en.wikipedia.org/wiki/HTTP_301[301 Moved Permanently] を
返したら、リダイレクトを追従しよう。

[#109]
== {SHOULD} APIを保守的に設計する

サービスプロバイダAPIの設計者は、クライアントから受け付けるものについて保守的で正確であるべきです。

* ペイロードやURL中の未知のフィールドは無視すべきでない。サーバは400のレスポンスコードを返して、
クライアントにエラーである旨を通知すべきである。
* 入力データの制約(フォーマット、範囲、長さなど)の定義には正確にしたがい、入力チェックして違反があれば、専用のエラーを返す。
* (機能要求に準拠している限りでは) 例えば文字列の長さの範囲を定義するなどして、より限定的で制限の強い方を選択する。そうすることで、互換性ある拡張として進化の自由を与えつつ、実装を単純化できるかもしれません。

未知の入力フィールドを無視しないというのは、ポステルの法則 (https://cacm.acm.org/magazines/2011/8/114933-the-robustness-principle-reconsidered/fulltext[The
Robustness Principle Reconsidered]) から逸脱していますが、これを強く推奨します。
サーバは次のような問題に気付き、サポートするものを明示すべきです。

* 未知の入力フィールドを無視することは、PUTにとって任意ではないことになります。
続くGETのレスポンスは非対称になり、PUTの"置換"セマンティクスとデフォルトの期待する動作は
HTTPで
(https://tools.ietf.org/html/rfc7231#section-4.3.4[RFC7231 Section
4.3.4] をみてください)
未知の入力フィールドを受け入れない(即ち無視しない)のと、続くGETレスポンスでそれを返すのとでは、
異なるシチュエーションであり、PUTセマンティクスに準拠したものであることに注意してください。
* あるクライアントエラーはサーバには認識できない。例えば、属性名にタイプミスがあれば、
サーバエラーなしには無視されてしまう。クライアントが任意の入力フィールドを与えたつもり
だったとしても、サーバはクライアントの意図した追加のフィールドなのか、フィールド名を間違って送ったのか
区別できないのである。
* 入力データ構造の将来の拡張は、すでに無視されているフィールドと競合するかもしれない。
そうなると、互換性は無くなるだろう。つまり、このフィールドを別の型として既に使ってるクライアントを破壊することになる。

特定の状況では、(既知の)入力フィールドがどこからも必要とされていなければ、
「not used anymore」の記述をAPI定義に書いておくか、サーバがこの特定のパラメータを無視する限り
API定義から削除するかしましょう。


[#110]
== {MUST} 拡張できるように、常にトップレベルのデータ構造としてJSONオブジェクトを返す

レスポンスボディには、常に将来の拡張を考慮して、常にトップレベルのデータ構造として(例えばArrayではなく)JSONオブジェクトを返さなければなりません。
JSONオブジェクトは属性を追加することによって、互換性を維持した拡張ができます。
これがレスポンスの拡張が簡単になる理由であり、例えば後からページネーションを追加したりということが、
後方互換性を崩すことなく可能になります。

[#111]
== {MUST} Open APIの定義をデフォルトで拡張に対してオープンとして扱う

Open API 2.0仕様では、オブジェクトのデフォルト拡張についてはあまり仕様化されておらず、
拡張に関しては `additionalProperties` のように、JSONスキーマキーワードを再定義したものになっています。
私たちの互換性ガイドライン全般にしたがうと、Open APIオブジェクト定義は、JSONスキーマの
http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.18[Section
5.18 "additionalProperties"] のようにデフォルトで拡張に対してオープンであるとみなすことができます。

Open API 2.0に関していえば、
これは `additionalProperties` 宣言が、オブジェクト定義を拡張可能にする必要がないことを意味します。

* データを受け取るAPIクライアントが、 `additionalProperties` 宣言が無いからといって、
拡張がされないものと仮定してはならないし、サーバから送られてきた処理できないフィールドは
無視しなくてはならない。そうすることで、APIサーバはデータフォーマットを拡張していけるようになる。
* APIサーバが予期しないデータを受け取るときは、ちょっと事情が異なる。フィールドを無視する代わりに
クライアントにこれらのフィールドが保存されなかったことを通知するために、
サーバは定義されていないフィールドを含むリクエストを拒否 ＿してもよい＿。
API設計者はPUT/POST/PATCHリクエストについて、予期しないフィールドをどう扱うか、
ドキュメントに明記しなければならない。

APIフォーマットは `additionalProperties` をfalseと宣言してはなりません。将来的にオブジェクトが拡張されるのを防ぐためです。

このガイドラインはデフォルトの拡張可能性に焦点を当てているのであって、
ある状況下では単なる値として `additionalProperties` を使うことを否定はしていません。
例えば、 <<216>> を参照。

[#112]
== {SHOULD} 列挙型の代わりに、上限なしの値リスト(x-extenible-enum)を使う

列挙型は値の閉集合であり、完全性が仮定されていて拡張は意図されていません。
この列挙型のクローズドな原則は、これを拡張しなきゃいけなくなったときに互換性の問題となってあらわれます。
これの問題を回避するために、列挙型の代わりに、上限のない値リストを使うことを強く推奨します。

例外として以下の場合は列挙型を使用してもかまいません。

1. 例えば値のリストが外部のツールやインタフェースに依存しないなど、APIが列挙型の値を完全に制御できる
2. 将来の機能を考慮可能、不可能に関わらず完全な値リストである

上限なしの値リストを特定するために、次のように `x-extensible-enum` のマーカーを使います。

[source,yaml]
----
deliver_methods:
  type: string
  x-extensible-enum:
    - parcel
    - letter
    - email
----

*注意:* `x-extensible-enum` は、JSONスキーマに準拠していませんが、大抵のツールには無視されます。

[#113]
== {SHOULD} バージョニングを避ける

RESTful APIを変更するときは、互換性をたもつ方法でおこない、APIのバージョンが新たに作られてしまうことを避けましょう。複数のバージョンはシステムを理解するのも、テストするのも、保守するのも、進化させるのも、運用するのも、リリースするのも全部を複雑化してしまいます。
(http://martinfowler.com/articles/enterpriseREST.html[こちらも参照ください])

互換性を維持する方法でAPIを変更出来ないのであれば、以下の3つのどれかを選択してください。

* 古いリソースのバリアントに追加する形で、新しいリソース(バリアント)を作る。
* 新たにエンドポイントを作る。 つまり、新しいAPIをもった(新しいドメイン名で)新しいアプリケーションを作るということです。
* 同じマイクロサービスで古いAPIもサポートしつつ、新しいバージョンのAPIを作る。

さまざまなデメリットがあるので、バージョニングは何としても避けたいところで、私たちは最初の2つのアプローチのみを使うことを強く推奨しています。

[#114]
== {MUST} メディアタイプバージョニングを使う

APIバージョニングを避けられないのであれば、(URIバージョニングの代わりに、以下に示すように)
メディアタイプバージョニングを利用したマルチバージョンRESTful APIを設計しなければなりません。
メディアタイプバージョニングは、コンテントネゴシエーションをサポートするので、密結合度合いは
緩和されます。したがってリリース管理の複雑さも減少することでしょう。

メディアタイプバージョニング: バージョン情報とメディアタイプは、Content-TypeのHTTPヘッダで与えられます。
例えば application/x.zalando.cart+json;version=2 のように。
非互換な変更があるときは、リソースに新しいメディアタイプバージョンがふられます。
新しいバージョンを生成するために、コンシューマとプロデューサはContent-TypeとAcceptのHTTPヘッダを使って
コンテントネゴシエーションできるのです。
注意: このバージョニングはURIやメソッドには適用できません。リクエストおよびレスポンスのコンテントスキーマにのみ適用可能です。

この例では、クライアントはレスポンスの新しいバージョンのみをリクエストします。

[source,http]
----
Accept: application/x.zalando.cart+json;version=2
----

クライアントと同様に、サーバもContent-Typeヘッダに新しいバージョンを送る宣言をして
レスポンスします。

[source,http]
----
Content-Type: application/x.zalando.cart+json;version=2
----

ヘッダバージョニングを使うべきなのは、以下の点にあります。

* リクエストとレスポンスのヘッダにバージョンを含めることで可視性が増す
* バージョンごとのプロキシキャッシュを有効にするために、Content-TypeをVaryヘッダに含めることができる

ヒント: 非互換の変更が必要になるまでは、通常の`application/json`メディアタイプのままにしておきましょう。

ヒント: https://github.com/OAI/OpenAPI-Specification/issues/146#issuecomment-117288707[このIssueのコメント] は(フラグメントが削除されることを利用した)回避策に言及していますが、 https://github.com/OAI/OpenAPI-Specification/issues/146[OpenAPIは今のところ、公式にはコンテントネゴシエーションをサポートしていません]。 新しいバージョンしか文書化しないという別の手もありますが、サーバは古いバージョンも受け付けるようにしなければなりません。

さらに: https://blog.apisyouwonthate.com/api-versioning-has-no-right-way-f3c75457c0b7[APIバージョニングに「正解」はない] では、自説にこだわることなく破壊的変更をどう扱うかを、異なるバージョニングのアプローチで全体感を述べています。

[#115]
== {MUST} URIバージョニングを使わない

URIバージョニングとは、/v1/customers のように、パスに(メジャー)バージョン番号を含ませる方法です。

API利用者は、APIプロバイダがデプロイされリリースされるまで待たなくてはなりません。
もしコンシューマもまた、ワークフローを追従できるよう(HATEOAS)ハイパーメディアリンクをサポートするのであれば、これはたちまち複雑化します。特にハイパーリンクで結ばれたサービス依存関係のあるところで、URLバージョンニングを使うと、バージョンアップの調整もまた困難です。
この密結合で複雑なリリース管理になるのを避けるためには、URIバージョニングは避けたほうがよいでしょう。
代わりに(上で示したような)メディアタイプバージョニングとコンテントネゴシエーションを使いましょう。
