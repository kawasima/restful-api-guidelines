[[http-requests]]
= HTTPリクエスト

[#148]
== {MUST} HTTPメソッドを正しく使う

以下に示すように、標準のHTTPメソッドの意味に沿うようにしましょう。

[[get]]
=== GET

GETリクエストは、単一のリソースの読み込み、またはリソースの集合のクエリのために使用されます。

* 個々のGETリクエストは、リソースが存在しなければ通常404となる。
* リソースのコレクションへのGETのリクエストは、(リストが空であれば) 200を、
(リスト自体が存在しなければ) 404が返る。
* GETリクエストはボディのペイロードをもってはいけない。

*注意:* リソースのコレクションへのGETリクエスト、<<pagination>>だけでなく、
十分なフィルタメカニズムを提供するべきです。

[[get-with-body]]
=== "ボディ付きのGET"

GETでの構造をもつリクエストは、クライアントやロードバランサ、サーバのサイズ制限に引っかかることがあり、
APIでもときどきこの問題に直面します。
私たちはAPIが標準に準拠する(すなわちサーバサイドでGETのボディは無視されなくてはならない)よう要求するので、
API設計者は次の2つのうち何れかを選択しなければなりません。

1.  URLエンコードされたクエリパラメータ付きのGET:
クライアント、ゲートウェイ、サーバの通常のサイズ制限を守りつつ
クエリパラメータにリクエスト情報をエンコードできるのであれば、
これが第1の選択肢です。リクエスト情報は、複数のクエリパラメータ分散してもたせてもよいし、
単一のパラメータにURLエンコードしてもたせてもかまいません。
2.  ボディコンテンツ付きのPOST: URLエンコードされたクエリパラメータ付きのGETが
どうしても制限に引っかかる場合は、ボディコンテンツ付きのPOSTを使わねばなりません。
この場合、エンドポイントは`GET with body`ヒントを必ずドキュメントに付けて、
GETの意味での呼び出しであることを伝えなければなりません。

*注意:* ヘッダに構造化されたリクエスト情報をエンコードすることは選択肢にはなりません。
コンセプト上の観点から、常にリソース名とクエリパラメータ(つまりURLになるもの)で
操作の意味を表さなくてはなりません。
リクエストヘッダは、例えばFlowIDのような、一般的な文脈情報のために予約されています。
おまけにクエリパラメータとヘッダのサイズ上限には、これで決まりというものはなく、
クライアント、ゲートウェイ、サーバの設定に依存したものです。
だから、ヘッダに切り替えたからといって何も問題は解決しないのです。

[[put]]
=== PUT

PUTのリクエストは、リソース *全体* の作成、更新に使われます。
単一のリソース、リソースのコレクション両方が対象です。PUTリクエストは、
»_URLが表すリソースを、このオブジェクトで既存のリソースと置き換えてください_«
という意味になります。

* PUTリクエストは通常はコレクションでなく単一リソースに適用されるものです。
コレクションに対するPUTは、その全体を置き換えることを暗に意味するからです。
* PUTリクエストは更新前に暗黙的にリソースの作成をおこなうことによって、
存在しないリソースに対しても問題を起こしません。
* PUTリクエストが成功したら、URLによって表現されるリソース *全体* が更新されるだろう (後続の読み取りにも同じペイロードが返される)。
* PUTリクエストが成功したら、(更新オブジェクトを返すならば) 200を (何も返さないならば) 204を、
(リソースが新規に生成された場合は) 201をステータスコードとして返す。

*注意:* PUTリクエストと関連したリソースIDは、クライアントが保持し、URLパスセグメントで受け渡しします。
同一のリソースに2度PUTしても、冪等である必要があり同じ結果を返さなくてはなりません。
もしPUTがリソースの作成に適用されたら、リソースIDとしてはURIのみが許可されるべきです。
もしURIが利用できない場合は、POSTが優先されるべきです。

PUTを使うときに意図せず同時更新してしまうことを防ぐため、<<182,`ETag` と `If-(None-)Match`>>ヘッダの
組み合わせで、コンフリクトを表明し変更を失わないようにするために、サーバに厳密な要求を送るようにしましょう。
<<optimistic-locking>>セクションでもこのアプローチの代替案を記述しています。

[[post]]
=== POST

POSTは慣例的には、リソースのコレクションのエンドポイントに、単一のリソースを作成するのに使われますが、
単一リソースエンドポイントでも他のものと同じように使えます。

コレクションのエンドポイントは、»_URLによって識別されるリソースのコレクションにオブジェクトを追加してください_« 、
単一のエンドポイントは、»_URLによって識別されるリソースのコレクションに対してリクエストを実行してください_« という意味になる。

* POSTリクエストはリソースのコレクションだけに適用されるべきである。通常単一リソースに対しては、
これは未定義の意味をもつ。
* POSTリクエストが成功したら、サーバは1つまたは複数のリソースを作成し、そのURI/URLをレスポンスとして返す。
* POSTリクエストは成功したら、ふつうは(リソースがアプデートされたら) 200を、(リソースが作成されたら) 201を、
(リクエストは受け付けたが、まだ完了していないのであれば) 202を返す。

*より一般的に:* POSTは、他のHTTPメソッドだと十分でないシナリオのためにも使われるべきである。
例えば複雑なGET、URL長の制約を超えるので、リクエストボディのペイロードとして渡さざるを得ない
(SQLのような構造化)クエリがそれにあたります。
そのような場合は、POSTがワークアラウンドとして使われていることをドキュメントに明記しましょう。

*注意:* POSTリクエストと関連したリソースIDは、サーバで作成・管理され、レスポンスのペイロードで
クライアントに返されます。
同じリソースを2回POSTすると、POSTには冪等性は必須ではないので、複数リソースインスタンスが
作られてしまうかもしれません。
もし重複したリクエストを識別するのに使える外部URIが存在すれば、冪等にPOSTを実装するベストプラクティスとなります。

[[patch]]
=== PATCH

PATCHリクエストは、単一リソースの部分更新にのみ使われます。つまりリソースフィールドの
特定のサブセットのみが置き換わります。
そのリクエストは、
»_この変更リクエストに対応するURLで特定されるリソースを変更してください_«
という意味になります。
変更リクエストの意味は、HTTP標準では定義されていないので、適したメディアタイプを使い
API仕様に記述しなければなりません。

* PATCHリクエストは、通常単一リソースに適用される。コレクションリソースに対するPATCHは、
コレクションまるごとパッチ更新することを暗に示しているので、あまり使われない。
* PATCHリクエストはリソースインスタンスが存在しないものに対しては、通常安定的ではない。
* PATCHリクエストが成功したら、ペイロード中の変更リクエストに定義されているとおりに、
サーバはURLによって指し示されたリソースを更新するだろう。
* PATCHリクエストが成功したら通常、(更新されたコンテンツを含むならば) 200 を (何も返さないならば) 204のステータスコードを返します。

*注意:* PATCHを正しく実装するのは些かトリッキーなので、
<<106,後方互換性ある変更>> がされる限り、
私たちはエンドポイントにつき次のパターンのどれか1つを選択するよう強く推奨します。
好ましい順に並べると:

1.  リソースの更新にはオブジェクトまるごと全体を渡すPUTを使う (つまりPATCHを一切使わない)
2.  リソースの一部を更新するためだけに、部分的なオブジェクトでPATCHを使う (これは
https://tools.ietf.org/html/rfc7396[JSON Merge Patch]
であり、部分的なリソース表現であることを示すために `application/merge-patch+json`
のメディアタイプを使う)
3.  http://tools.ietf.org/html/rfc6902[JSON Patch] で規定されたPATCHを使う。
専用のメディアタイプ `application/json-patch+json` は、リソース変更の方法を
指示していることを表す。
4.  メディアタイプで定義された手段で、リクエストがリソースを変更しない場合は、
PATCHの代わりに (何が起きたかの正しい記述がされた) POSTを使う。

特に https://tools.ietf.org/html/rfc7396[JSON Merge Patch] は、
特に(リソースの一部として) 巨大なコレクションの中の1つのオブジェクトを更新しようとすると、
すぐに限界を感じることでしょう。
この場合、 http://tools.ietf.org/html/rfc6902[JSON Patch] が可読性のあるPATCHリクエストである限りは有効な手段です。
(http://erosb.github.io/post/json-patch-vs-merge-patch[JSON patch vs. merge] をみてください)。

PATHを使うとき、気付かずに同時更新してしまうのを防ぐために、
<<182,`ETag` と `If-Match`>>ヘッダを組み合わせて、コンフリクトを避け、
変更内容がロストしないようにすることを検討してください。

[#delete]
=== DELETE

DELETEリクエストはリソースの削除に使われ、
»_URLによって特定されるリソースを削除してください_«
ということを意味します。

* DELETEリクエストは、通常単一リソースに適用される。コレクションリソースに対するDELETEは、
コレクションまるごと削除することを暗に示しているので、あまり使われない。
* DELETEリクエストが成功したら通常、(削除されたリソースを返すならば) 200を、(何も返さないならば) 204のステータスコードを使う。
* DELETEリクエストが失敗したら通常、(リソースが見つからない場合は) 404を、(リソースが既に削除済みならば) 410のステータスコードを使う。

[[head]]
=== HEAD

HEADリクエストは、単一のリソースまたはリソースのコレクションについてのヘッダ情報だけを取得するのに使われます。

* HEADはGETと正確に同じ意味を持ちますが、ボディは返されず、ヘッダのみが返されます。

[[options]]
=== OPTIONS

OPTIONSリクエストは、与えられたエンドポイントの利用可能な操作(HTTPメソッド)が何かを調べるのに使われます。

* OPTIONSは通常、利用可能なメソッドをカンマ繋ぎにしたものを(`Allow:`-ヘッダで)返すか、
リンクテンプレートのリストとして返されます。

*注意:* OPTIONSを実装することはあまりありません。

[#149]
== {MUST} メソッド毎の安全性と冪等性を満たす

HTTPメソッドには以下の性質の有無に違いがあります。

* 冪等性。すなわち、何度実行されてもサーバの状態は同じ影響しか与えないこと。(注意: これは同じレスポンスまたはステータスコードを返す必要はありません)
* 安全性。すなわち状態変化のような副作用がないこと。

メソッドの実装は、次の基本的な性質が満たされなければなりません。

[cols=",,",options="header",]
|=============================
|HTTPメソッド |安全性 |冪等性
|OPTIONS |Yes |Yes
|HEAD |Yes |Yes
|GET |Yes |Yes
|PUT |No |Yes
|POST |No |No
|DELETE |No |Yes
|PATCH |No |No
|=============================

[#154]
== {SHOULD} クエリパラメータのコレクションフォーマットは明示的に定義する

クエリパラメータで値の集合を渡すには、いくつかの方法があります。
どれか1つを選択し、API定義に明示します。
OpenAPIプロパティの http://swagger.io/specification/[`collectionFormat`]
は、クエリパラメータのフォーマットを指定するのに使われます。

複数値をもつクエリパラメータには、`csv` または `multi` いずれかのフォーマットを使うべきです。

[,cols="15%,25%,60%",options="header",]
|=======================================================================
|Collection Format |Description |Example
|`csv` |カンマで分割された値 |`?parameter=value1,value2,value3`

|`multi` |複数パラメータのインスタンス
|`?parameter=value1&parameter=value2&parameter=value3`
|=======================================================================

コレクションフォーマットを選択する際には、ツールのサポート、特殊文字のエスケープ、URLの最大長
を超えないかに注意してください。
