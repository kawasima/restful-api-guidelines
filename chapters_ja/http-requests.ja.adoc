[[http-requests]]
= HTTPリクエスト

[#148]
== {MUST} HTTPメソッドを正しく使う

以下に示すように、標準のHTTPメソッドの意味に沿うようにしましょう。

[[get]]
=== GET

{GET}リクエストは、単一のリソースの読み込み、またはリソースの集合のクエリのために使用されます。

* 個々の{GET}リクエストは、リソースが存在しなければ通常{404}となる。
* リソースのコレクションへの{GET}のリクエストは、(リストが空であれば) {200}を、
(リスト自体が存在しなければ) {404}が返る。
* {GET}リクエストはボディのペイロードをもってはいけない。({GET-with-Body}参照)

*注意:* リソースのコレクションへの{GET}リクエストは、<<137, フィルタ>>や<<pagination>>の機能を十分に提供するべきです。

[[get-with-body]]
=== "ボディ付きのGET"

{GET}での構造をもつリクエストは、クライアントやロードバランサ、サーバのサイズ制限に引っかかることがあり、APIでもときどきこの問題に直面します。
私たちはAPIが標準に準拠する(すなわちサーバサイドで{GET}のボディは無視されなくてはならない)よう要求するので、API設計者は次の2つのうち何れかを選択しなければなりません。

1.  URLエンコードされたクエリパラメータ付きの{GET}:
クライアント、ゲートウェイ、サーバの通常のサイズ制限を守りつつ
クエリパラメータにリクエスト情報をエンコードできるのであれば、
これが第1の選択肢です。リクエスト情報は、複数のクエリパラメータ分散してもたせてもよいし、
単一のパラメータにURLエンコードしてもたせてもかまいません。
2.  ボディコンテンツ付きの{POST}: URLエンコードされたクエリパラメータ付きの{GET}が
どうしても制限に引っかかる場合は、ボディコンテンツ付きの{POST}を使わねばなりません。
この場合、エンドポイントは{GET-with-Body}`ヒントを必ずドキュメントに付けて、
GETの意味での呼び出しであることを伝えなければなりません。

*注意:* ヘッダに構造化されたリクエスト情報をエンコードすることは選択肢にはなりません。
コンセプト上の観点から、常にリソース名とクエリパラメータ(つまりURLになるもの)で
操作の意味を表さなくてはなりません。
リクエストヘッダは、例えばFlowIDのような、一般的な文脈情報のために予約されています。
おまけにクエリパラメータとヘッダのサイズ上限には、これで決まりというものはなく、
クライアント、ゲートウェイ、サーバの設定に依存したものです。
だから、ヘッダに切り替えたからといって何も問題は解決しないのです。

*ヒント:* {GET-with-body}は拡張クエリパラメータが使われるので、{cursor}はもはや<<160,カーソルベースページネーション>>の場合に、クエリフィルタをエンコードするのには使われません。結果として、クエリフィルタはボディに入れて送るのがベストプラクティスになります。{cursor}に適用されたクエリフィルタを全体のハッシュ値を含ませるようにすると、ページネーションの順番を保つことができます(<<161>>参照)。

[[put]]
=== PUT

{PUT}のリクエストは、リソース *全体* の *更新* (稀に作成)に使われます。
単一のリソース、リソースのコレクション両方が対象です。{PUT}リクエストは、
_"URLが表すリソースを、このオブジェクトで既存のリソースと置き換えてください"_
という意味になります。

* {PUT}リクエストは通常はコレクションでなく単一リソースに適用されるものです。
コレクションに対するPUTは、その全体を置き換えることを暗に意味するからです。
* {PUT}リクエストは更新前に、暗黙的にリソースの作成をおこなうことによって、
存在しないリソースに対しても問題を発生しないようにできます。
* {PUT}リクエストが成功したら、URLによって表現されるリソース *全体* が更新されます (後続の読み取りにも同じペイロードが返される)。
* {PUT}リクエストが成功したら、(更新オブジェクトを返すならば) {200}を (何も返さないならば) {204}を、
(リソースが新規に生成された場合は) {201}をステータスコードとして返す。

*重要:* (少なくともトップレベルの)リソースの生成については、{PUT}よりも{POST}を使うのがベストプラクティスです。そうすることで、リソースIDを残すことができるし、次に示すような{PUT}を使った更新セマンティクスに集中できるようになります。

*注意:* {PUT}がリソースの生成に使われるのは稀なケースなので、リソースIDはクライアントが保持し、URLパスセグメントで受け渡しします。
同一のリソースに2度{PUT}しても、冪等である必要があり同じ結果を返さなくてはなりません(<<149>>参照)。

*ヒント:* {PUT}を使うときに意図せず同時更新してしまうことを防ぐため、<<182,`ETag` と `If-(None-)Match`>>ヘッダの
組み合わせで、コンフリクトを表明し変更を失わないようにするために、サーバに厳密な要求を送るようにしましょう。
<<optimistic-locking>>セクションでもこのアプローチの代替案を記述しています。

[[post]]
=== POST

{POST}は慣例的には、リソースのコレクションのエンドポイントに、単一のリソースを作成するのに使われますが、単一リソースエンドポイントでも他のものと同じように使えます。コレクションのエンドポイントにとっての意味は"_URLによって識別されるリソースのコレクションにオブジェクトを追加してください_"というものになります。

* {POST}リクエストが成功すると、サーバは1つまたは複数の新しいリクエストを生成し、レスポンスにそれらのURI/URLを含みます。
* 成功した{POST}リクエストは、(もしリソースが更新されたら) {200}を、(もしリソースが生成されたのであれば) {201}を、(もしリクエストが受け付けられたがまだ終了してないならば) {202}を、例外的に(もし本当のリソースを返さないならば) {Location}ヘッダを付けた{204}を返すのが通常です。

単一のリソースエンドポイントに対しての意味は、 _"URLで識別されるリソースに与えられたリクエストを実行してください"_ というものになります。

*より一般的に:* {POST}は、他のHTTPメソッドだと十分でないシナリオのためにも使われるべきです。そのような場合には、{POST}がワークアラウンドとして使われる事実をドキュメント化するようにしましょう。({GET-with-Body}参照)

*注意:* {POST}リクエストと関連したリソースIDは、サーバで作成・管理され、レスポンスのペイロードでクライアントに返されます。

*ヒント:* 同じリソースを2回POSTする際、<<idempotent>>は必要では *ありません* (<<149>>をチェックしてみよう)。でも、これを防ぐために<<229>>しましょう。

[[patch]]
=== PATCH

{PATCH}リクエストは、単一リソースの部分更新にのみ使われます。つまりリソースフィールドの
特定のサブセットのみが置き換わります。
そのリクエストは、
"_この変更リクエストに対応するURLで特定されるリソースを変更してください_"
という意味になります。
変更リクエストの意味は、HTTP標準では定義されていないので、適したメディアタイプを使い
API仕様に記述しなければなりません。

* {PATCH}リクエストは、通常単一リソースに適用される。
* {PATCH}リクエストはリソースインスタンスが存在しないものに対しては、通常安定的ではない。
* {PATCH}リクエストが成功したら、ペイロード中の変更リクエストに定義されているとおりに、
サーバはURLによって指し示されたリソースを更新するだろう。
* PATCHリクエストが成功したら通常、(更新されたコンテンツを含むならば) {200} を (何も返さないならば) {204}のステータスコードを返します。

*注意:* {PATCH}を正しく実装するのは些かトリッキーなので、
<<106,後方互換性ある変更>> がされる限り、
私たちはエンドポイントにつき次のパターンのどれか1つを選択するよう強く推奨します。
好ましい順に並べると:

1.  リソースの更新にはオブジェクトまるごと全体を渡す{PUT}を使う (つまり{PATCH}を一切使わない)
2.  リソースの一部を更新するためだけに、部分的なオブジェクトで{PATCH}を使う (これは {RFC-7396}[JSON Merge Patch]
であり、部分的なリソース表現であることを示すために `application/merge-patch+json`
のメディアタイプを使う)
3. {RFC-6902}[JSON Patch] で規定された{PATCH}を使う。
専用のメディアタイプ `application/json-patch+json` は、リソース変更の方法を
指示していることを表す。
4.  メディアタイプで定義された手段で、リクエストがリソースを変更しない場合は、
{PATCH}の代わりに (何が起きたかの正しい記述がされた) {POST}を使う。

特に {RFC-7396}[JSON Merge Patch] は、
特に(リソースの一部として) 巨大なコレクションの中の1つのオブジェクトを更新しようとすると、
すぐに限界を感じることでしょう。
この場合、 {RFC-6902}[JSON Patch] が可読性のある{PATCH}リクエストである限りは有効な手段です。
(http://erosb.github.io/post/json-patch-vs-merge-patch[JSON patch vs. merge] をみてください)。

*注意:* 同じリソースに対して2回パッチすることは、<<idempotent>>である必要は *ありません* (<<149>>をチェックしてみましょう)。でも、これを防ぐために<<229>>しましょう。

*ヒント:* {PACTH}を使うとき、気付かずに同時更新してしまうのを防ぐために、
<<182>>で、サーバがコンフリクトを避け、変更内容がロストしないようできるます。<<optimistic-locking>>と<<229>>により詳細と選択肢があります。

[#delete]
=== DELETE

{DELETE}リクエストはリソースの削除に使われ、
"_URLによって特定されるリソースを削除してください_"
ということを意味します。

* {DELETE}リクエストは、通常単一リソースに適用される。コレクションリソースに対する{DELETE}は、
コレクションまるごと削除することを暗に示しているので、あまり使われない。
* {DELETE}リクエストが成功したら通常、(削除されたリソースを返すならば) {200}を、(何も返さないならば) {204}のステータスコードを使う。
* DELETEリクエストが失敗したら通常、(リソースが見つからない場合は) {404}を、(リソースが既に削除済みならば) {410}のステータスコードを使う。

*重要:* {DELETE}でリソースを削除した後のそのリソースに対する{GET}リクエストは、削除後にリソースがどう表現されるかによって、{404} (not found)と{410} (gone)のどちらかを返すことが期待されます。この操作の後、リソースがそのエンドポイントでアクセス可能である必要はありません。

[[head]]
=== HEAD

{HEAD}リクエストは、単一のリソースまたはリソースのコレクションについてのヘッダ情報だけを取得するのに使われます。

* {HEAD}は{GET}と正確に同じ意味を持ちますが、ボディは返されず、ヘッダのみが返されます。

*ヒント:* {HEAD}は特に、{ETag}ヘッダとともに、大きなリソースやコレクションリソースが更新されたかどうかを効率的に確認するのに使われます。

[[options]]
=== OPTIONS

{OPTIONS}リクエストは、与えられたエンドポイントの利用可能な操作(HTTPメソッド)が何かを調べるのに使われます。

* {OPTIONS}レスポンスは通常、利用可能なメソッドをカンマ繋ぎにしたものを(`Allow:`-ヘッダで)返すか、
リンクテンプレートのリストとして返されます。

*注意:* {OPTIONS}を実装することはあまりありませんが、リソースの全機能を示すのに使われます。

[#149]
== {MUST} メソッド毎に共通の性質を満たす

RESTfulサービスにおけるリクエストメソッドは...

* [[safe, 安全]]{RFC-safe} - リードオンリーで定義された操作は、 _意図的な副作用_ を持ってはならない。すなわちサーバの状態を変更してはならない。
* [[idempotent, 冪等]]{RFC-idempotent} - その操作が一回のみの実行でも、複数回の実行でも、サーバの状態に同じ _意図した効果_ しかもたらさない。 *注意:* これは操作が同じレスポンスまたはステータスコードを返すことまでは要求しない。
* [[cacheable, キャッシュ可能]]{RFC-cacheable} - レスポンスを将来の再利用のために保管できることを示す。一般に安全なメソッドへの要求は、サーバからの現在のレスポンスまたは権限のレスポンスを必要としない場合、キャッシュ可能となる。

*注意:* 上記の定義で_意図された(副)作用_ により、サーバはロギング、アカウンティング、プリフェッチなどの追加の状態変更する振る舞いを提供します。ただし、これらの実際の作用と状態変更が、その操作によって意図されたものであってはなりません。

メソッド実装は、 {RFC-7231}[RFC 7231] にしたがい、次の基本的な性質を満たさなければなりません。

[cols="15%,15%,35%,35%",options="header",]
|====================================================
| メソッド    | 安全性  | 冪等性 | キャッシュ可能性
| {GET}     | {YES} | {YES}      | {YES}
| {HEAD}    | {YES} | {YES}      | {YES}
| {POST}    | {NO}  | {AT} Noだが<<229>>と実現可能 | {AT}
もし特定の{POST}エンドポイントが<<safe>>であれば可能かもしれない。 *Hint:* 大抵のキャッシュではサポートされない。
| {PUT}     | {NO}  | {YES}      | {NO}
| {PATCH}   | {NO}  | {AT} Noだが<<229>>と実現可能 | {NO}
| {DELETE}  | {NO}  | {YES}      | {NO}
| {OPTIONS} | {YES} | {YES}      | {NO}
| {TRACE}   | {YES} | {YES}      | {NO}
|====================================================

*注意:* <<227>>

[#229]
== {SHOULD} `POST` と `PATCH` の冪等設計を検討する
多くの場合で、例えば同じリソースが並行して作成または変更されたり、複数回にわたって変更されたりする可能性がある場合など、クライアントが競合を明らかにし、リソースの重複(いわゆるゾンビリソース)や、更新内容の消失を防ぐために、{POST}と{PATCH}の<<Idempotent,冪等性>>を設計することが役立ちます。<<idempotent>> APIエンドポイントを設計するには、次の3つのパターンのいずれかを適用することを検討する必要があります。

* リクエストに<<182,`If-Match` ヘッダ>>を介してリソース固有の *条件付きキー* を与える。キーは一般にリソースのメタ情報です。たとえば、 _hash_ や _バージョン番号_ 等で、よく一緒に保存されます。<<idempotent>>な挙動を保証するために、同時に発生する生成と更新を検出できるようになります。(<<182>>参照)
* リソース固有の *セカンダリキー* は、リクエストボディ中のリソースプロパティとして提供されます。 _セカンダリキー_ はリソースに永続的に保存され、異なるクライアントから複数のリソース生成要求が発生する場合に、一意なセカンダリキーを探すことによって、<<idempotent>> な振る舞いを保証できるようになります。(<<231>>参照)
* クライアント固有の *冪等キー* は、リクエストの{Idempotency-Key}ヘッダを介して与えられます。キーはリソースの一部ではありませんが、リクエストをリトライする際の<<idempotent>>な挙動を保証するために、元のレスポンスを指し示すために一時的に保存されます。(<<230>>参照)

*注意:* *条件付きキー* と *セカンダリキー* は、同時リクエストを扱うのに注力していて、 *冪等キー* は<<idempotent,上で定義された冪等性>>よりも _より強い_ 要求となる正確に同じレスポンスを返すということに注力しています。したがって他の2つと組み合わせることができます。

あなたのユースケースにどのパターンが適しているかを決めるために、各パターンの主要な判断軸を示した以下の表をよく見てください。

[,cols="46%,18%,18%,18%",options="header",]
|==================================================================================
|                               | 条件付きキー | セカンダリキー | 冪等キー
| Applicable with                       | {PATCH} | {POST}  | {POST}/{PATCH}
| HTTP Standard                         | {YES}   | {NO}    | {NO}
| Prevents duplicate (zombie) resources | {YES}   | {YES}   | {NO}
| Prevents concurrent lost updates      | {YES}   | {NO}    | {NO} 
| Supports safe retries                 | {YES}   | {YES}   | {YES}
| Supports exact same response          | {NO}    | {NO}    | {YES}
| Can be inspected (by intermediaries)  | {YES}   | {NO}    | {YES}
| Usable without previous {GET}         | {NO}    | {YES}   | {YES}
|==================================================================================

*注意:* {PATCH}に適用可能なパターンは、同じプロパティを提供する{PUT}および{DELETE}に同じ方法で適用できます。

安全なリトライをサポートすることを主目的するならば、<<182,条件付きキー>>と<<231,セカンダリキー>> パターンを<<230,冪等キー>>パターンの前に適用します。

[#231]
== {SHOULD} 冪等な `POST` 設計のためにセカンダリキーを使う

生成時の{POST} <<idempotent>>を設計するための最も重要なパターンは、重複リソースの問題(いわゆるゾンビリソース)を無くすために、リクエストボディにリソース固有の *セカンダリキー* を導入します。

セカンダリキーは、リソースに _代替キー_ または(もし複数のプロパティからなるのであれば) _複合キー_ として永続的に保存され、サーバサイドで実行される一意制約によって上記問題からガードします。
最良かつ自然に存在する候補は、新しく生成されたリソースと _1対1_ の関連をもつ別のリソース(親プロセス識別子など)を指す _一意の外部キー_ です。

セカンダリーキーの例として良い例は、注文リソースにおけるショッピングカートIDです。

*注意:* {Idempotency-Key}無しにセカンダリキーパターンを使うときは、全ての一連のリトライはコード{409}(conflict)で失敗すべきです。リソースが明確に定義された振る舞いを実装する元のリソースであるという確信がないのであれば、{200}を使うのは避けたほうがよいでしょう。コンテンツなしで{204}を使うことも、同様に適切に定義された選択肢です。

[#154]
== {SHOULD} ヘッダとクエリパラメータのコレクションフォーマットを定義する

カンマで区切られた値のリストか、パラメータを複数回繰り返すかのどちらかで、ヘッダとクエリパラメータで値の集合を渡すことができます。

[,cols="14%,30%,39%,17%",options="header",]
|=========================================================================
| Parameter Type | Comma-separated Values | Multiple Parameters | Standard
| Header | `Header: value1,value2` | `Header: value1, Header: value2`
| {RFC-7230}#section-3.2.2[RFC 7230 Section 3.2.2]

| Query | `?param=value1,value2` | `?param=value1&param=value2`
| {RFC-6570}#section-3.2.8[RFC 6570 Section 3.2.8]
|=========================================================================

Open APIでは一度に両方のスキーマをサポートできないので、API仕様ではどちらかを明示的に定義しなければなりません。

[,cols="14%,40%,46%",options="header",]
|===============================================================
| Parameter Type | Comma-separated Values | Multiple Parameters
| Header | `style: simple, explode: false` | not allowed (see
  {RFC-7230}#section-3.2.2[RFC 7230 Section 3.2.2])
| Query  | `style: form, explode: false`   | `style: form, explode: true`
|===============================================================

コレクションフォーマットを選択する際には、ツールのサポート、特殊文字のエスケープ、URLの最大長を超えないかに注意してください。

[#236]
== {SHOULD} クエリパラメータを使ったシンプルなクエリ言語を設計する

クエリパラメータを使って、大部分のAPIのリソース固有のクエリ言語を記述することを推奨します。これはクエリパラメータがHTTPネイティブであり、拡張が容易で、HTTPクライアントおよびWebフレームワークで優れた実装サポートがあるためです。

クエリパラメータは、次の観点をもつべきです。

* 対応するプロパティの参照 (存在する場合)
* 値の範囲。例えば境界を含む、含まない。
* 比較のセマンティクス (equals, less than, greater than など)
* 他のクエリと組み合わせたときの影響。例えば _and_ なのか _or_ なのか

クエリパラメータがどのように命名され、どのように使われるかは、個々のAPI設計者次第です。次の例を参考にしてください。

* `name=Zalando`, プロパティの等価性にもとづく要素のクエリ
* `age=5`, 論理的なプロパティにもとづく、要素のクエリ
** `age`  という要素は、存在せず `birthday` のみ持っているケースを想定。
* `max_length=5`, 上限、下限にもとづく (`min` と `max`)
* `shorter_than=5`, 特定の用語を使う。例えば _length_ 
* `created_before=2019-07-17` や `not_modified_since=2019-07-17`
** 特定の用語を使う。例えば: _before_, _after_, _since_, _until_

私たちは、特定の名前を支持したり反対したりはしません。最終的にAPIはそのドメインに最も適した用語を自由に選択すべきだからです。

[#237]
== {SHOULD} JSONを使った複雑なクエリ言語を設計する

<236, query parameters>>に基づく最小のクエリ言語は、単一の方法のみで結合される少ないフィルタ(例えば _and_ セマンティクス) を使う単純なユースケースに適しています。一般的にもシンプルなクエリ言語の方が、複雑なものよりも好まれます。

APIによってはより複雑なクエリ言語が必要なこともあります。代表的な例は検索(ファセット検索を含む)APIと、製品カタログAPIです。

これらのAPIは他のAPIと以下の点で異なります。

* 尋常でない多くの利用可能なフィルタを使う
* 動的で拡張可能なリソースモデルのための動的フィルタ
* 演算子の自由な選択 例えば `and`, `or` , `not`

特定の複雑なクエリ言語に合うAPIは、ネストしたJSONデータ構造を使い、Open APIを使って直接定義するのがよいでしょう。これには以下のメリットがあります。

* クライアントがデータ構造を扱うのが簡単である。
** 特別なライブラリのサポートが必要ない
** 文字列結合や手動エスケープが必要ない
* サーバがデータ構造を扱うのが簡単である。
** 特別なトークナイザが必要ない。
** セマンティクスはテキストトークンよりもデータ構造にある。
* 他のHTTPメソッドでも構成できる。
* APIはOpen APIで完全に定義しきれる。
** 外部ドキュメントや文法が必要ない。
** 既存の手段は誰もが知っている。

<<json-guidelines, JSON-specific rules>> と、おそらくきっと<<get-with-body, `GET`-with-body>>パターンを使うことになるだろう。

=== 例

次のJSONドキュメントは、構造化クエリがどのようになるかを示したものです。

[source,json]
----
{
  "and": {
    "name": {
      "match": "Alice"
    },
    "age": {
      "or": {
        "range": {
          ">": 25,
          "<=": 50
        },
        "=": 65
      }
    }
  }
}
----

以下からもインスピレーションが得れるでしょう。

* https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl.html[Elastic Search: Query DSL]
* https://graphql.org/learn/queries/[GraphQL: Queries]


[#226]
== {MUST} 暗黙的なフィルタリングをドキュメント化する

あるコレクションリソースやクエリが、持っている要素全てではなく、現在のクライアントにアクセスが許可されたものだけを返すことがあります。

次の場合に、暗黙的フィルタリングされます。

* 親の{GET}リクエストで返されるリソースのコレクション
* リソースの詳細で返されるフィールド

そのような場合、暗黙的なフィルタリングはAPI仕様として(そのdescriptionに)書かれなくてはなりません。

暗黙的なフィルタリングするときは、<<227,caching considerations>> も考えよう。

例:

会社 _Foo_ の従業員が当社の企業間サービスの一つに{GET}アクセスする場合、法律上の理由から、会社が所有または契約管理していない他のビジネスパートナーを法事してはなりません。私たちが、会社 _Bar_ と一緒にビジネスしていることは決してバレてはなりません。

`Foo` で動作するコンシューマからはレスポンスは次のように見える。

[source,json]
----
{
    "items": [
        { "name": "Foo Performance" },
        { "name": "Foo Sport" },
        { "name": "Foo Signature" }
    ]
}
----

`Bar` で動作するコンシューマからはレスポンスは次のように見える。

[source,json]
----
{
    "items": [
        { "name": "Bar Classics" },
        { "name": "Bar pour Elle" }
    ]
}
----

API仕様はこのように何を特定するかを示すべきです。

[source,yaml]
----
paths:
  /business-partner:
    get:
      description: >-
        Get the list of registered business partner.
        Only the business partners to which you have access to are returned.
----
