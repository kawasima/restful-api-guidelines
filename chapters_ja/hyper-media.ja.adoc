[[hypermedia]]
= ハイパーメディア

[#162]
== {MUST} REST成熟モデル2を使う

私たちは
http://martinfowler.com/articles/richardsonMaturityModel.html#level2[REST
成熟度レベル2] のイケてる実装を目指します。
そうすることでHTTP動詞とステータスコードをフル活用した、リソース指向APIを構築できるようになるからです。
これらのガイドラインを通じて、これは多くのルールによって表現されています。

* <<138>>
* <<141>>
* <<148>>
* <<150>>

これはHATEOASではありませんが、以下に示すルールで記述されるように、
APIに正しいリンク関連を設計することにとらわれるべきではありません。

[#163]
== {MAY} REST成熟モデル3を使う - HATEOAS

私たちは基本的には、
http://martinfowler.com/articles/richardsonMaturityModel.html#level3[REST
成熟レベル3] を実装すことはおすすめしません。
HATEOASは、クライアントとサーバのREST APIを通じたやりとりしたり、
私たちのeコマースのSaaSプラットフォームの一部として複雑な業務機能を提供したりする、
私たちのSOA文脈においては、価値のない複雑さをAPIにもたらします。

私たち主な関心は、HATEOASのもたらす利点にあります。
(詳細な議論は https://www.infoq.com/news/2014/03/rest-at-odds-with-web-apis[RESTistential
Crisis over Hypermedia APIs] や https://jeffknupp.com/blog/2014/06/03/why-i-hate-hateoas/[Why I Hate HATEOAS] 、を参照ください)

* 私たちは標準仕様言語でコード外に明示的にAPIを定義して、<<100,APIファーストの原則>>にしたがいます。
HATEOASはSOAクライアントエンジニアにとって、APIの自己記述性にはあまり価値を感じません:
クライアントエンジニアは、APIリファレンス定義に、(リソースの状態に依存した)必要なリンクや使い方の記述を見ることができるのですから。
* 一般的なHATEOASクライアントは、APIについての前提知識を必要とせず、与えられたハイパーメディア情報に
基づいたAPIの機能を探すことができるものですが、これは理論的な概念で、
私たちは実際に動いてるのを見たことがないし、私たちのSOA機構にフィットしません。
またOpenAPIの記述フォーマット(とそのツール)は、HATEOASのサポートも十分ではありません。
* 実際、HATEOASに似た(HALやJSON APIのような)仕様も、URLエンドポイントやHTTPメソッドの性質から
情報を取り出すことによって、APIナビゲーションをサポートします。
したがってハイパーメディアはドメインモデルが徐々に変化していくときには、
結局クライアントは手動での変更が余儀なくされるのです。
* ハイパーメディアは人間にとっては意味のあるものですが、SOAクライアントにとってはそうでもありません。
私たちは、SOAクライアントがサービスドメイン境界にいるフロントエンドや人間に価値を届けることができる
ユースケースを想定しているのです。
* ハイパーメディアは、APIクライアントが'discovering'を使わずに、ショートカットを実装したり、
直接対象のリソースをターゲットにすることを防げません。

しかし、私たちはHATEOASを禁止するわけではありません。
その制限を理解し、複雑さを代償としてもより価値のある利用シーンがあるのであれば、HATEOASを使ってもかまいません。

[#217]
== {MUST} 絶対URIを使う

他のリソースへのリンクは、絶対URIでなくてはなりません。

*動機*: 相対URI (相対URLが絶対パスを使おうが相対パスを使おうが) の形式を露出させると、
クライアントサイドでは複雑性の混入を避けることができません。
埋め込みサブリソースのような機能を使うときは、絶対URIが与えられないとすれば、
ベースURIを明確にする必要があります。
絶対URIを使わないことの利点は、ペイロードサイズを小さくできること程度ですが、
それならば <<156,GZip圧縮>>を使った方がよいでしょう。

[#164]
== {MUST} 共通のハイパーテキストコントロールを使う

他のリソースへのリンクを埋め込むとき、共通のハイパーテキストコントロールオブジェクトを
使わなくてはなりません。ハイパーテキストコントロールオブジェクトには、少なくとも1つの属性が含まれます。

* `href`: ハイパーテキストコントロールがリンクしているリソースのURI。
私たちのすべてのAPIは、URIスキームとして HTTP(s) を使っている。

どんなハイパーテキストコントロールを含むAPIにおいても、
属性名 `href` はハイパーテキストコントロールの範囲内での使用用途で予約語となります。

ハイパーテキストコントロールのスキーマは、以下のモデルから導き出されます。

[source,yaml]
----
HttpLink:
  description: A base type of objects representing links to resources.
  type: object
  properties:
    href:
      description: Any URI that is using http or https protocol
      type: string
      format: uri
  required: [ "href" ]
----

`HttpLink` のようなオブジェクトをもつ属性の名前は、リンクとリンク先のリソースを含む
オブジェクトとの関係を明記します。
実装は http://www.iana.org/assignments/link-relations/link-relations.xhtml[IANA
Link Relation Registry] から適切なものを選んで、その名前を使うべきです。
このガイドでは属性名にはスネークケースが使われていますが、
IANAのリンクリレーション名は、ハイフンケース表記が使われています。IANA名のハイフンは、
アンダースコアに変換しなければなりません。
(例えば、IANAリンクリレーションタイプ `version-history` は属性 `version_history` になります)

特定のリンクオフジェクトは、リンクに加えて、
リンク先のリソースに関する追加情報や、リンク元のリソースとリンク先のリソースの関係など、
その他の属性を含ませることができます。

例えば、"Person" リソースを提供するサービスは、他の誰かと結婚していることを、
その結婚相手の (`id`, `name`) だけでなく、いつから配偶者関係にあるかを示す (`since`)
などを含んだハイパーテキストコントロールでモデル化します。

[source,json]
----
{
  "id": "446f9876-e89b-12d3-a456-426655440000",
  "name": "Peter Mustermann",
  "spouse": {
    "href": "https://...",
    "since": "1996-12-19",
    "id": "123e4567-e89b-12d3-a456-426655440000",
    "name": "Linda Mustermann"
  }
}
----

ハイパーテキストコントロールは、JSONモデルの範囲ではどこでも使えます。
この仕様においては http://stateless.co/hal_specification.html[HAL] が
使用可能ですが、APIの理解しやすさや使いやすさがもたらす価値よりも、
メタデータとデータの構造的な分離の有害さが上回るため、私たちはHALはおすすめいないし使いません。

[#165]
== {SHOULD} ページネーションや自己参照にシンプルなハイパーテキストコントロールを使う

コレクション内でのページネーションや自己参照のためのハイパーテキストコントロールは、
拡張共通ハイパーテキストコントロールを使うよりも、
http://www.iana.org/assignments/link-relations/link-relations.xml[リンクリレーション]
で定義されている (`next`, `prev`, `first`, `last`, `self`)
組合せたシンプルなURIを使うべきです。

ページネーション可能なコレクションの一番よい表現方法は、 <<pagination>> を見てください。

[#166]
== {MUST} JSONエンティティと一緒にはLinkヘッダは使わない

私たちは
http://tools.ietf.org/html/rfc5988#section-5[RFC 5988 で定義された `Link` ヘッダ] は、
JSONメディアタイプとは同時に使わないようにしています。
JSONペイロードに直接組み込まれたリンクを、共通化されていないリンクヘッダの文法よりも優先します。
