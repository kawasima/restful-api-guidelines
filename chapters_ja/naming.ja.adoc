[[api-naming]]
= APIの命名

[#223]
== {MUST-SHOULD} 機能本位の命名体系を使う

機能本位の命名は、あるアプリケーション群の中で、_ホスト_ や _権限_、 _イベント名_
のような各所から利用されるリソースに、整合性をもたせる強力で簡単な方法です。
そうすることで、コンポーネントについての意味のあるコンテキスト情報を
読み手に提供しつつ、名前の一意性も保証できます。
さらにもっとも重要なのは、技術的、組織的な変化の中でAPIを安定した状態が保たれるという点です。

拡大していく <<219, オーディエンス>> とともにAPIがこの利点を享受できるよう、
<<224, ホスト名>> や <<215, 権限名>>、 <<213, イベント名>> に関して、
次のような機能本位の命名体系にしたがうことを強く推奨します。

[cols="25%,75%,options="header"]
|================================================================
| *Functional Naming* | *オーディエンス*
| *must*   | external-public, external-partner, company-internal
| *should* | component-internal, business-unit-internal
|================================================================

機能本位の命名体系に導くために、
一意な `functional-name` が各機能コンポーネントに割り当てられます。
それはコンポーネントが属する機能グループのドメイン名からなり、
機能コンポーネントを一意に識別できる短い名前です。

[source,bnf]
----
<functional-name>       ::= <functional-domain>-<functional-component>
<functional-domain>     ::= [a-z][a-z0-9]*  -- 管理されたコンポーネントの機能グループ
<functional-component>  ::= [a-z][a-z0-9-]* -- 機能コンポーネント自身の名前
----

機能の命名パターンの詳細ルールについては、以下のものも参照ください。

* <<224>>
// * <<225>>
* <<213>>

[#224]
== {MUST} ホスト名の命名規約にしたがう

APIにおけるホスト名は、以下に示すようにそれぞれ <<219, オーディエンス>> ごとに
定められた機能の命名ルールに準拠すべきです。
(詳細は <<223>> の `<functional-name>` 定義を参照ください)

[source,bnf]
-----
<hostname>             ::= <functional-hostname> | <application-hostname>

<functional-hostname>  ::= <functional-name>.zalandoapis.com
-----

次に示すアプリケーション固有のレガシーな規約は、 <<223, 内部>> APIのホスト名に *だけ* 適用できます。

[source,bnf]
-----
<application-hostname> ::= <application-id>.<organization-unit>.zalan.do
<application-id>       ::= [a-z][a-z0-9-]*  -- アプリケーション識別子
<organization-id>      ::= [a-z][a-z0-9-]*  -- 組織単位の識別子。例えば、チームID
-----

[#129]
== {MUST} パスセグメントはハイフンで区切られた小文字を使う

例:

[source,http]
----
/shipment-orders/{shipment-order-id}
----

このルールは具体化されたパスセグメントに適用され、パスパラメータの名前は
この限りではありません。
例えば`{shipment_order_id}`は、パスパラメータとしてはOKです。

[#130]
== {MUST} クエリパラメータは、スネークケースを使う(決してキャメルケースにしない)

例:

[source]
----
customer_number, order_id, billing_address
----

[#132]
== {SHOULD} HTTPヘッダはハイフン区切りのパスカルケースにする

これは一貫性のためのルールです(他のほとんどのヘッダがこの規約にしたがっているためです)。
(ハイフンなしの)キャメルケースにするのは避けましょう。例外は「ID」のような共通の略語です。

例:

[source,http]
----
Accept-Encoding
Apply-To-Redirect-Ref
Disposition-Notification-Options
Original-Message-ID
----

参考: http://tools.ietf.org/html/rfc7230#page-22[HTTPヘッダは大文字・小文字を区別しない (RFC 7230)]


<<common-headers>> と <<proprietary-headers>> の章に、HTTPヘッダに関する
ガイダンスがもう少しあるので参照ください。

[#134]
== {MUST} リソース名は複数形にする

ふつうリソースインスタンスのコレクションが提供されます(すくなくともAPIは用意されるべきです)。
リソースがシングルトンである特別な場合が、カーディナリティ1のコレクションと考えます。

[#135]
== {MAY} 最初のパスセグメントに /api を付ける

たいていの場合、サービスによって提供されるすべてのリーソースは、公開APIの一部です。
それゆえにベースパスであるルート"/"は利用可能にしておくべきです。
もしサービスが非公開、内部APIをサポートしなきゃいけなくなったら、ベースパスとして"/api"を
付けておけば、公開APIと非公開APIのリソースを明確に分離しておくことができます。

[#136]
== {MUST} 末尾のスラッシュを避ける

末尾スラッシュに特定の意味をもたせてはなりません。リソースパスは
末尾にスラッシュがあろうがなかろうが、同じ結果を返さなければなりません。

[#137]
== {MAY} クエリストリングの規約を使う

もしソートやページネーション、フィルタ関数または他のアクションをサポートしたクエリを提供することになったら、
次に示す標準の命名規約にしたがってください。

* `q` — デフォルトのクエリパラメータ (つまりブラウザのタブ補完で使われる); そうでないものはskuのようなエンティティ特有の別名を持つべきである。
* `limit` — エンティティの数を制限する。ページネーションのセクションをみてください。ヒント: `size` を別のクエリ文字列として使うこともできます。
* `cursor` — キーベースのページのスタート地点。<<pagination>> セクション参照。
* `offset` — 数値のオフセットによるページのスタート地点。<<pagination>> セクション参照。
ヒント: limitとの組み合わせにおいては、offsetの代わりに `page` を使ってもよい。
* `sort` — ソートに使うフィールドをカンマで繋いだリスト。ソートの方向を指示するために、フィールドには + (昇順) または - (降順) のプレフィクスが付くことがある。例: /sales-orders?sort=+id
* `fields` — フィールドのサブセットのみを取得するため。<<157,_リソースフィールドのフィルタリングサポート_>> を参照ください。
* `embed` — エンティティの中身を展開する。 ( 記事エンティティの内部で、シルエットコードをシルエットオブジェクトに展開する). "展開"を正しく実装するのは難しいので、注意してやる必要がある。

[%hardbreaks]
