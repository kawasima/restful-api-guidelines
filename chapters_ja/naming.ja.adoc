[[api-naming]]
= APIの命名

[#223]
== {MUST-SHOULD} 機能本位の命名体系を使う

機能本位の命名は、あるアプリケーション群の中で、_ホスト_ や _権限_、 _イベント名_
のような各所から利用されるリソースに、整合性をもたせる強力で簡単な方法です。
そうすることで、コンポーネントについての意味のあるコンテキスト情報を
読み手に提供しつつ、名前の一意性も保証できます。
さらにもっとも重要なのは、技術的、組織的な変化の中でAPIを安定した状態が保たれるという点です。

拡大していく <<219, オーディエンス>> とともにAPIがこの利点を享受できるよう、
<<224, ホスト名>> や <<215, 権限名>>、 <<213, イベント名>> に関して、
次のような機能本位の命名体系にしたがうことを強く推奨します。

[cols="25%,75%,options="header"]
|================================================================
| *Functional Naming* | *オーディエンス*
| *must*   | external-public, external-partner
| *should* | company-internal, business-unit-internal
| *may*    | component-internal
|================================================================

機能本位の命名体系に導くために、
一意な `functional-name` が各機能コンポーネントに割り当てられます。
それはコンポーネントが属する機能グループのドメイン名からなり、
機能コンポーネントを一意に識別できる短い名前です。

[source,bnf]
----
<functional-name>       ::= <functional-domain>-<functional-component>
<functional-domain>     ::= [a-z][a-z0-9]*  -- 管理されたコンポーネントの機能グループ
<functional-component>  ::= [a-z][a-z0-9-]* -- 機能コンポーネント自身の名前
----

機能の命名パターンの詳細ルールについては、以下のものも参照ください。

* <<224>>
// * <<225>>
* <<213>>

[#224]
== {MUST} ホスト名の命名規約にしたがう

APIにおけるホスト名は、以下に示すようにそれぞれ <<219, オーディエンス>> ごとに
定められた機能の命名ルールに準拠すべきです。
(詳細は <<223>> の `<functional-name>` 定義を参照ください)

[source,bnf]
-----
<hostname>             ::= <functional-hostname> | <application-hostname>

<functional-hostname>  ::= <functional-name>.zalandoapis.com
-----

次に示すアプリケーション固有のレガシーな規約は、 <<219, component-internal>> APIのホスト名に *だけ* 適用できます。

[source,bnf]
-----
<application-hostname> ::= <application-id>.<organization-unit>.zalan.do
<application-id>       ::= [a-z][a-z0-9-]*  -- アプリケーション識別子
<organization-id>      ::= [a-z][a-z0-9-]*  -- 組織単位の識別子。例えば、チームID
-----

[#129]
== {MUST} パスセグメントはハイフンで区切られた小文字を使う

例:

[source,http]
----
/shipment-orders/{shipment-order-id}
----

このルールは具体化されたパスセグメントに適用され、パスパラメータの名前は
この限りではありません。
例えば`{shipment_order_id}`は、パスパラメータとしてはOKです。

[#130]
== {MUST} クエリパラメータは、スネークケースを使う(決してキャメルケースにしない)

例:

[source]
----
customer_number, order_id, billing_address
----

[#132]
== {SHOULD} HTTPヘッダはハイフン区切りのパスカルケースにする

これは一貫性のためのルールです(他のほとんどのヘッダがこの規約にしたがっているためです)。
(ハイフンなしの)キャメルケースにするのは避けましょう。例外は「ID」のような共通の略語です。

例:

[source,http]
----
Accept-Encoding
Apply-To-Redirect-Ref
Disposition-Notification-Options
Original-Message-ID
----

参考: {RFC-7230}#page-22[HTTPヘッダは大文字・小文字を区別しない (RFC 7230)]

<<common-headers>> と <<proprietary-headers>> の章に、HTTPヘッダに関する
ガイダンスがもう少しあるので参照ください。

[#134]
== {MUST} リソース名は複数形にする

ふつうリソースインスタンスのコレクションが提供されます(すくなくともAPIは用意されるべきです)。
リソースがシングルトンである特別な場合が、カーディナリティ1のコレクションと考えます。

[#135]
== {SHOULD} ベースパスとして /api を付けない

たいていの場合、サービスによって提供されるすべてのリーソースは、公開APIの一部です。
それゆえにベースパスであるルート"/"は利用可能にしておくべきです。

もし非公開の内部APIもサポートする必要があるならば(例えばサービスが特定の運用サポート機能のために)、2つの異なるAPI仕様をメンテナンスし、<<219, API audience>>を提供することを推奨します。
双方のAPIとも `/api` をベースパスとして使うべきではありません。

私たちはAPIのベースパスを、デプロイ時の可変な設定の一部として考えています。したがって、この情報は、 https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.2.md#server-object[server object] に定義されなければなりません。

[#136]
== {MUST} 末尾のスラッシュを避ける

末尾スラッシュに特定の意味をもたせてはなりません。リソースパスは
末尾にスラッシュがあろうがなかろうが、同じ結果を返さなければなりません。

[#137]
== {MUST} クエリストリングの規約を使う

もしソートやページネーション、フィルタ関数または他のアクションをサポートしたクエリを提供することになったら、
次に示す標準の命名規約にしたがってください。

* [[q]]{q}: デフォルトのクエリパラメータ (つまりブラウザのタブ補完で使われる); skuのようにエンティティ特有の別名を持つべきである。
* [[sort]]{sort}: ソートに使うフィールドをカンマで繋いだリスト(<<154>>で定義される)。ソートの方向を指示するために、フィールドには + (昇順) または - (降順) のプレフィクスが付くことがある。例: /sales-orders?sort=+id
* [[fields]]{fields}: フィールドのサブセットのみを取得するため。<<157>> 参照。
* [[embed]]{embed}: サブエンティティの中身を展開したり、組み込んだりするためのフィールド名表現。例えば記事エンティティの中に、シルエットコードをシルエットオブジェクトに拡張するのに使われる。 {embed}を正しく実装するのは難しいので、注意してやる必要がある。
* [[offset]]{offset}: 数値のオフセットによるページのスタート地点。<<pagination>> セクション参照。
* [[cursor]]{cursor}: ページへのOpaqueポインタで、クライアントが検査したり構築したりすることない。通常は(暗号化)ページ位置、つまり最初または最後のページ要素の識別子、ページネーションの方向、およびコレクションを再作成するために適用されたクエリフィルタをエンコードする。<<pagination>> セクション参照。
* [[limit]]{limit}: クライアントから1ページのエンティティ数を制限する数を与える。<<pagination>> セクション参照。

