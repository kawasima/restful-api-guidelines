[[appendix-best-practices]]
[appendix]
= ベストプラクティス

実際のガイドラインの一部ではないけれど、RESTful APIの実装で直面する共通の課題に光明をもたらすべく、ベストプラクティスをこのセクションにまとめます。

[[optimistic-locking]]
== RESTful APIにおける楽観ロック

=== はじめに
楽観ロックは同一エンティティに同時に書き込みが発生し、データが整合性が失われることを防ぐのに使われます。
クライアントは常に最初にエンティティのコピーを取ってきて、これを更新しなければなりません。
もしその間に別のバージョンが作られたら、更新は失敗すべきです。これがうまくいくように、更新を実行する前に、クライアントはサービスによってチェックされたバージョンの参照の種類を提供しなければなりません。

詳しくは<<put, PUTメソッドの使用法についてのセクション>>をみてください。PUTを用いたリソースの更新方法についてより詳細に記述しています。

RESTful APIは通常、エンティティのリストを返すような検索のエンドポイントをもちます。更新すべきエンティティの現在のバージョンを取得するため使われる検索エンドポイントと組み合わせて、楽観ロックを実装する方法はいくつかあります。

=== If-MatchヘッダとETagヘッダ
ETagヘッダは更新前に単一のエンティティリソースに対するGETリクエストを実行することによって取得できます。つまり、検索エンドポイントを使う際には、追加のリクエストが必要ということです。

例:
[source,http]
----
< GET /orders

> HTTP/1.1 200 OK
> {
>   "items": [
>     { id: "O0000042"},
>     { id: "O0000043"}
>   ]
> }

< GET /orders/BO0000042

> HTTP/1.1 200 OK
> ETag: osjnfkjbnkq3jlnksjnvkjlsbf
> { id: "BO0000042", ... }

< PUT /orders/O0000042
< If-Match: osjnfkjbnkq3jlnksjnvkjlsbf
< { id: "O0000042", ... }

> HTTP/1.1 204 No Content

エンティティのETagが、既に更新されて一致しなかったら、以下のレスポンスになります。

> HTTP/1.1 412 Precondition failed
----

==== Pros
* RESTfulな解決手段です

==== Cons
* 多くの追加リクエストが必要になってしまう。

[[etag-in-result-entities]]
=== 結果エンティティにおける `ETag`
すべてのエンティティに、追加のプロパティとして{ETag}を付けて返します。
複数のエンティティを含むレスポンスでは、エンティティそれぞれに後続の{PUT}で使用可能な異なるETagが付与されます。

例:
[source,http]
----
< GET /orders

> HTTP/1.1 200 OK
> {
>   "items": [
>     { id: "O0000042", etag: "osjnfkjbnkq3jlnksjnvkjlsbf", ... },
>     { id: "O0000043", etag: "kjshdfknjqlöwjdsljdnfkjbkn", ... }
>   ]
> }

< PUT /orders/O0000042
< If-Match: osjnfkjbnkq3jlnksjnvkjlsbf
< { id: "O0000042", ... }

> HTTP/1.1 204 No Content

GETの後の更新で、エンティティのETagが変わってしまっていたら、以下のレスポンスが返ります。

> HTTP/1.1 412 Precondition failed
----

==== Pros
* パーフェクトな楽観ロックである

==== Cons
* HTTPヘッダに付与すべき情報が、業務オブジェクトに入り込んでしまっている。

=== バージョン番号
バージョン番号をエンティティのプロパティに含む方法です。
PUTがリクエストがされたとき、ペイロードに含まれたバージョン番号を、サーバはデータベース中のバージョン番号と突き合わせします。

例:
[source,http]
----
< GET /orders

> HTTP/1.1 200 OK
> {
>   "items": [
>     { id: "O0000042", version: 1, ... },
>     { id: "O0000043", version: 42, ... }
>   ]
> }

< PUT /orders/O0000042
< { id: "O0000042", version: 1, ... }


> HTTP/1.1 204 No Content
----

GETのあと別リクエストで更新されていたら、データベース中のバージョン番号はリクエストボディで与えられたものより、大きな値になっているので、409を返します。

[source,http]
----
> HTTP/1.1 409 Conflict
----

==== Pros
* パーフェクトな楽観ロックである

==== Cons
* HTTPヘッダで実現すべき機能が、業務オブジェクトに入り込んでしまっている。

=== Last-Modified / If-Unmodified-Since
HTTP1.0では、ETagの仕様はなく、楽観ロックには日時に基づいた手法が使われていました。
これは現在でもHTTPプロトコルの一部であり利用できます。

すべてのレスポンスには、HTTP dateを値にもつLast-Modifiedヘッダが含ませます。
PUTリクエストを使った更新をリクエストするとき、クライアントはIf-Unmoified-Since ヘッダを使って、
Last-Modifiedで受け取った値をセットします。
サーバはもしエンティティの最終更新日時が、ヘッダの日時よりも後であれば、このリクエストを拒否します。

GETとPUTの間で発生した変更が上書きされるような状況を効果的に検出できます。
複数の結果エンティティの場合、Last-Modifiedヘッダには、すべてのエンティティの最終更新日時うち最新のものがセットされるでしょう。
これはGETとPUTの間で発生するエンティティのどんな変更も、コンフリクトが検出可能で、バッチの残りをロックすることなく行えることを保証します。

Example:
[source,http]
----
< GET /orders

> HTTP/1.1 200 OK
> Last-Modified: Wed, 22 Jul 2009 19:15:56 GMT
> {
>   "items": [
>     { id: "O0000042", ... },
>     { id: "O0000043", ... }
>   ]
> }

< PUT /block/O0000042
< If-Unmodified-Since: Wed, 22 Jul 2009 19:15:56 GMT
< { id: "O0000042", ... }

> HTTP/1.1 204 No Content

GETのあと更新され、エンティティの最終更新日時が与えられた日時よりも後であれば、412を返します。

[source,http]
> HTTP/1.1 412 Precondition failed
----

==== Pros
* 昔から使われてきた方法で枯れている。
* 業務オブジェクトに干渉しない。HTTPヘッダのみと使ってロックできる。
* 実装がとても簡単である
* 検索エンドポイントの結果のエンティティを更新するとき、更新リクエスト以外の追加ののリクエストは必要ない。

==== Cons
* もしクライアントが異なる2つのインスタンスと通信している場合、その時刻同期が完全にできていないと、
ロックは失敗する可能性がある。

=== 結論
私たちは、 _{Last-Modified} / {If-Unmodified-Since}_ か _結果エンティティの{ETag}_ のどちらかを
使うことをおすすめします。
